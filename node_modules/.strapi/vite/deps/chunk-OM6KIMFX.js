import {
  pluginId
} from "./chunk-URXKF3BA.js";
import {
  adminApi
} from "./chunk-ESSUPVTG.js";
import {
  createSlice
} from "./chunk-SCCN2M3I.js";
import {
  require_react_dom
} from "./chunk-AWHRF5BE.js";
import {
  require_jsx_runtime
} from "./chunk-LMPM4PM5.js";
import {
  require_react
} from "./chunk-D3I3COXH.js";
import {
  __toESM
} from "./chunk-LK32TJAX.js";

// node_modules/@strapi/upload/dist/admin/future/utils/translations.mjs
var getTranslationKey = (id) => `${pluginId}.${id}`;

// node_modules/@strapi/upload/dist/admin/future/store/uploadProgress.mjs
var initialState = {
  isVisible: false,
  isMinimized: false,
  progress: 0,
  totalFiles: 0,
  files: [],
  errors: [],
  uploadId: 0
};
var computeProgress = (files) => {
  if (files.length === 0) return 0;
  const totalSize = files.reduce((sum, f) => sum + f.size, 0);
  if (totalSize === 0) {
    const completed = files.filter((f) => f.status === "complete" || f.status === "error" || f.status === "cancelled").length;
    return Math.round(completed / files.length * 100);
  }
  const completedSize = files.filter((f) => f.status === "complete" || f.status === "error" || f.status === "cancelled").reduce((sum, f) => sum + f.size, 0);
  return Math.round(completedSize / totalSize * 100);
};
var uploadProgressSlice = createSlice({
  name: "uploadProgress",
  initialState,
  reducers: {
    openUploadProgress(state, action) {
      state.isVisible = true;
      state.isMinimized = false;
      state.progress = 0;
      state.totalFiles = action.payload.totalFiles;
      state.files = action.payload.fileNames.map((name, index) => ({
        name,
        index,
        status: "pending",
        size: action.payload.fileSizes[index] || 0
      }));
      state.errors = [];
      state.uploadId += 1;
    },
    setFileUploading(state, action) {
      const { index } = action.payload;
      if (state.files[index]) {
        state.files[index].status = "uploading";
      }
    },
    setFileComplete(state, action) {
      const { index, file } = action.payload;
      if (state.files[index]) {
        state.files[index].status = "complete";
        state.files[index].file = file;
      }
      state.progress = computeProgress(state.files);
    },
    setFileError(state, action) {
      const { index, name, message } = action.payload;
      if (state.files[index]) {
        state.files[index].status = "error";
        state.files[index].error = message;
      }
      state.errors = [
        ...state.errors,
        {
          name,
          message
        }
      ];
      state.progress = computeProgress(state.files);
    },
    updateProgress(state, action) {
      state.progress = action.payload;
    },
    addUploadErrors(state, action) {
      state.errors = [
        ...state.errors,
        ...action.payload
      ];
    },
    closeUploadProgress(state) {
      state.isVisible = false;
      state.isMinimized = false;
      state.progress = 0;
      state.totalFiles = 0;
      state.files = [];
      state.errors = [];
    },
    toggleMinimize(state) {
      state.isMinimized = !state.isMinimized;
    },
    cancelUpload(state) {
      state.files = state.files.map((file) => {
        if (file.status === "pending" || file.status === "uploading") {
          return {
            ...file,
            status: "cancelled"
          };
        }
        return file;
      });
      state.progress = computeProgress(state.files);
    },
    setUploadFailed(state, action) {
      state.files = state.files.map((file) => {
        if (file.status === "pending" || file.status === "uploading") {
          return {
            ...file,
            status: "error",
            error: action.payload.message
          };
        }
        return file;
      });
      state.progress = 100;
      state.errors = [
        ...state.errors,
        {
          name: "Upload Error",
          message: action.payload.message
        }
      ];
    },
    retryCancelledFiles(state) {
      state.files = state.files.map((file) => {
        if (file.status === "cancelled") {
          return {
            ...file,
            status: "pending"
          };
        }
        return file;
      });
      state.progress = computeProgress(state.files);
    }
  }
});
var { openUploadProgress, setFileUploading, setFileComplete, setFileError, updateProgress, addUploadErrors, closeUploadProgress, toggleMinimize, cancelUpload, setUploadFailed, retryCancelledFiles } = uploadProgressSlice.actions;
var uploadProgressReducer = uploadProgressSlice.reducer;

// node_modules/@strapi/upload/dist/admin/future/services/api.mjs
var uploadedFiles = /* @__PURE__ */ new Map();
var registerUploadedFiles = (uploadId, files) => {
  uploadedFiles.set(uploadId, files);
};
var getUploadedFiles = (uploadId) => {
  return uploadedFiles.get(uploadId);
};
var abortControllers = /* @__PURE__ */ new Map();
var registerAbortController = (uploadId, controller) => {
  abortControllers.set(uploadId, controller);
};
var unregisterAbortController = (uploadId) => {
  abortControllers.delete(uploadId);
};
var abortUpload = (uploadId) => {
  const controller = abortControllers.get(uploadId);
  if (controller) {
    controller.abort();
    unregisterAbortController(uploadId);
  }
};
var parseSSEEvents = (chunk) => {
  const events = [];
  const blocks = chunk.split("\n\n").filter(Boolean);
  for (const block of blocks) {
    let event = "";
    let data = "";
    for (const line of block.split("\n")) {
      if (line.startsWith("event: ")) {
        event = line.slice(7);
      } else if (line.startsWith("data: ")) {
        data = line.slice(6);
      }
    }
    if (event && data) {
      events.push({
        event,
        data
      });
    }
  }
  return events;
};
var fetchUploadStream = async ({ token, formData, signal }) => {
  const backendURL = window.strapi.backendURL;
  const headers = {};
  if (token) {
    headers.Authorization = `Bearer ${token}`;
  }
  return fetch(`${backendURL}/upload/unstable/stream`, {
    method: "POST",
    headers,
    body: formData,
    signal
  });
};
var processSSEStream = async ({ response, dispatch, indexMapper = (i) => i }) => {
  const reader = response.body.getReader();
  const decoder = new TextDecoder();
  let streamResult = null;
  let buffer = "";
  while (true) {
    const { done, value } = await reader.read();
    if (done) {
      break;
    }
    buffer += decoder.decode(value, {
      stream: true
    });
    const lastDoubleNewline = buffer.lastIndexOf("\n\n");
    if (lastDoubleNewline === -1) {
      continue;
    }
    const completePart = buffer.slice(0, lastDoubleNewline + 2);
    buffer = buffer.slice(lastDoubleNewline + 2);
    const events = parseSSEEvents(completePart);
    for (const { event, data } of events) {
      const parsed = JSON.parse(data);
      const mappedIndex = indexMapper(parsed.index);
      switch (event) {
        case "file:uploading": {
          const payload = parsed;
          dispatch(setFileUploading({
            name: payload.name,
            index: mappedIndex,
            total: payload.total,
            size: payload.size
          }));
          break;
        }
        case "file:complete": {
          const payload = parsed;
          dispatch(setFileComplete({
            index: mappedIndex,
            file: payload.file
          }));
          break;
        }
        case "file:error": {
          const payload = parsed;
          dispatch(setFileError({
            index: mappedIndex,
            name: payload.name,
            message: payload.message
          }));
          break;
        }
        case "stream:complete": {
          const payload = parsed;
          streamResult = {
            data: payload.data,
            errors: payload.errors
          };
          break;
        }
        default:
          console.error(`[SSE Upload] unknown event: ${event}`, parsed);
      }
    }
  }
  return streamResult;
};
var uploadApi = adminApi.enhanceEndpoints({
  addTagTypes: [
    "Asset",
    "Folder"
  ]
}).injectEndpoints({
  endpoints: (builder) => ({
    /**
    * Stream upload files to the /upload/unstable/stream endpoint.
    * Reads SSE stream for per-file progress updates.
    */
    uploadFilesStream: builder.mutation({
      queryFn: async ({ formData, totalFiles }, { dispatch, getState }) => {
        var _a, _b;
        const token = (_a = getState().admin_app) == null ? void 0 : _a.token;
        const files = formData.getAll("files");
        const fileInfoJson = formData.get("fileInfo");
        const fileInfo = JSON.parse(fileInfoJson);
        const fileNames = fileInfo.map((info) => info.name);
        const fileSizes = files.map((file) => file.size);
        dispatch(openUploadProgress({
          totalFiles,
          fileNames,
          fileSizes
        }));
        dispatch(updateProgress(0));
        const uploadId = getState().uploadProgress.uploadId;
        registerUploadedFiles(uploadId, files);
        const abortController = new AbortController();
        registerAbortController(uploadId, abortController);
        try {
          const response = await fetchUploadStream({
            token,
            formData,
            signal: abortController.signal
          });
          if (!response.ok || !response.body) {
            unregisterAbortController(uploadId);
            let errorMessage2 = "Upload request failed";
            try {
              const errorData = await response.json();
              if ((_b = errorData.error) == null ? void 0 : _b.message) {
                errorMessage2 = errorData.error.message;
              } else if (errorData.message) {
                errorMessage2 = errorData.message;
              }
            } catch {
              errorMessage2 = `Upload failed with status ${response.status}`;
            }
            dispatch(setUploadFailed({
              message: errorMessage2
            }));
            return {
              error: {
                name: "UnknownError",
                message: errorMessage2,
                status: response.status
              }
            };
          }
          const streamResult = await processSSEStream({
            response,
            dispatch
          });
          unregisterAbortController(uploadId);
          if (streamResult && streamResult.data.length > 0) {
            return {
              data: streamResult
            };
          }
          const errorMessage = "No files were uploaded successfully";
          dispatch(setUploadFailed({
            message: errorMessage
          }));
          return {
            error: {
              name: "UnknownError",
              message: errorMessage
            }
          };
        } catch (err) {
          unregisterAbortController(uploadId);
          if (err instanceof DOMException && err.name === "AbortError") {
            return {
              error: {
                name: "UnknownError",
                message: "Upload cancelled"
              }
            };
          }
          const errorMessage = err instanceof Error ? err.message : "Network error occurred";
          dispatch(setUploadFailed({
            message: errorMessage
          }));
          return {
            error: {
              name: "UnknownError",
              message: errorMessage
            }
          };
        }
      },
      invalidatesTags: [
        {
          type: "Asset",
          id: "LIST"
        }
      ]
    }),
    /**
    * Retry uploading cancelled files.
    * Retrieves original File objects and re-uploads only the cancelled ones.
    */
    retryCancelledFilesStream: builder.mutation({
      queryFn: async (_, { dispatch, getState }) => {
        var _a, _b;
        const token = (_a = getState().admin_app) == null ? void 0 : _a.token;
        const { uploadId, files: stateFiles } = getState().uploadProgress;
        const cancelledFiles = stateFiles.filter((f) => f.status === "cancelled");
        if (cancelledFiles.length === 0) {
          return {
            error: {
              name: "UnknownError",
              message: "No cancelled files to retry"
            }
          };
        }
        const originalFiles = getUploadedFiles(uploadId);
        if (!originalFiles) {
          return {
            error: {
              name: "UnknownError",
              message: "Original files not found"
            }
          };
        }
        const indexMapping = cancelledFiles.map((f) => f.index);
        const filesToRetry = cancelledFiles.map((f) => originalFiles[f.index]);
        dispatch(retryCancelledFiles());
        const formData = new FormData();
        const fileInfoArray = filesToRetry.map((file) => ({
          name: file.name,
          caption: null,
          alternativeText: null,
          folder: null
        }));
        filesToRetry.forEach((file) => {
          formData.append("files", file);
        });
        formData.append("fileInfo", JSON.stringify(fileInfoArray));
        const abortController = new AbortController();
        registerAbortController(uploadId, abortController);
        try {
          const response = await fetchUploadStream({
            token,
            formData,
            signal: abortController.signal
          });
          if (!response.ok || !response.body) {
            unregisterAbortController(uploadId);
            let errorMessage = "Retry request failed";
            try {
              const errorData = await response.json();
              if ((_b = errorData.error) == null ? void 0 : _b.message) {
                errorMessage = errorData.error.message;
              } else if (errorData.message) {
                errorMessage = errorData.message;
              }
            } catch {
              errorMessage = `Retry failed with status ${response.status}`;
            }
            for (const originalIndex of indexMapping) {
              dispatch(setFileError({
                index: originalIndex,
                name: stateFiles[originalIndex].name,
                message: errorMessage
              }));
            }
            return {
              error: {
                name: "UnknownError",
                message: errorMessage,
                status: response.status
              }
            };
          }
          const streamResult = await processSSEStream({
            response,
            dispatch,
            indexMapper: (serverIndex) => indexMapping[serverIndex]
          });
          unregisterAbortController(uploadId);
          if (streamResult && streamResult.data.length > 0) {
            return {
              data: streamResult
            };
          }
          return {
            error: {
              name: "UnknownError",
              message: "No files were uploaded successfully"
            }
          };
        } catch (err) {
          unregisterAbortController(uploadId);
          if (err instanceof DOMException && err.name === "AbortError") {
            return {
              error: {
                name: "UnknownError",
                message: "Retry cancelled"
              }
            };
          }
          const errorMessage = err instanceof Error ? err.message : "Network error occurred";
          return {
            error: {
              name: "UnknownError",
              message: errorMessage
            }
          };
        }
      },
      invalidatesTags: [
        {
          type: "Asset",
          id: "LIST"
        }
      ]
    })
  })
});
var { useUploadFilesStreamMutation, useRetryCancelledFilesStreamMutation } = uploadApi;

// node_modules/@strapi/upload/node_modules/@radix-ui/react-context/dist/index.mjs
var React = __toESM(require_react(), 1);
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
function createContext2(rootComponentName, defaultContext) {
  const Context = React.createContext(defaultContext);
  const Provider = (props) => {
    const { children, ...context } = props;
    const value = React.useMemo(() => context, Object.values(context));
    return (0, import_jsx_runtime.jsx)(Context.Provider, { value, children });
  };
  Provider.displayName = rootComponentName + "Provider";
  function useContext2(consumerName) {
    const context = React.useContext(Context);
    if (context) return context;
    if (defaultContext !== void 0) return defaultContext;
    throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
  }
  return [Provider, useContext2];
}
function createContextScope(scopeName, createContextScopeDeps = []) {
  let defaultContexts = [];
  function createContext3(rootComponentName, defaultContext) {
    const BaseContext = React.createContext(defaultContext);
    const index = defaultContexts.length;
    defaultContexts = [...defaultContexts, defaultContext];
    const Provider = (props) => {
      var _a;
      const { scope, children, ...context } = props;
      const Context = ((_a = scope == null ? void 0 : scope[scopeName]) == null ? void 0 : _a[index]) || BaseContext;
      const value = React.useMemo(() => context, Object.values(context));
      return (0, import_jsx_runtime.jsx)(Context.Provider, { value, children });
    };
    Provider.displayName = rootComponentName + "Provider";
    function useContext2(consumerName, scope) {
      var _a;
      const Context = ((_a = scope == null ? void 0 : scope[scopeName]) == null ? void 0 : _a[index]) || BaseContext;
      const context = React.useContext(Context);
      if (context) return context;
      if (defaultContext !== void 0) return defaultContext;
      throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
    }
    return [Provider, useContext2];
  }
  const createScope = () => {
    const scopeContexts = defaultContexts.map((defaultContext) => {
      return React.createContext(defaultContext);
    });
    return function useScope(scope) {
      const contexts = (scope == null ? void 0 : scope[scopeName]) || scopeContexts;
      return React.useMemo(
        () => ({ [`__scope${scopeName}`]: { ...scope, [scopeName]: contexts } }),
        [scope, contexts]
      );
    };
  };
  createScope.scopeName = scopeName;
  return [createContext3, composeContextScopes(createScope, ...createContextScopeDeps)];
}
function composeContextScopes(...scopes) {
  const baseScope = scopes[0];
  if (scopes.length === 1) return baseScope;
  const createScope = () => {
    const scopeHooks = scopes.map((createScope2) => ({
      useScope: createScope2(),
      scopeName: createScope2.scopeName
    }));
    return function useComposedScopes(overrideScopes) {
      const nextScopes = scopeHooks.reduce((nextScopes2, { useScope, scopeName }) => {
        const scopeProps = useScope(overrideScopes);
        const currentScope = scopeProps[`__scope${scopeName}`];
        return { ...nextScopes2, ...currentScope };
      }, {});
      return React.useMemo(() => ({ [`__scope${baseScope.scopeName}`]: nextScopes }), [nextScopes]);
    };
  };
  createScope.scopeName = baseScope.scopeName;
  return createScope;
}

// node_modules/@strapi/upload/node_modules/@radix-ui/react-use-controllable-state/dist/index.mjs
var React5 = __toESM(require_react(), 1);

// node_modules/@strapi/upload/node_modules/@radix-ui/react-use-layout-effect/dist/index.mjs
var React2 = __toESM(require_react(), 1);
var useLayoutEffect2 = (globalThis == null ? void 0 : globalThis.document) ? React2.useLayoutEffect : () => {
};

// node_modules/@strapi/upload/node_modules/@radix-ui/react-use-controllable-state/dist/index.mjs
var React22 = __toESM(require_react(), 1);

// node_modules/@radix-ui/react-use-effect-event/node_modules/@radix-ui/react-use-layout-effect/dist/index.mjs
var React3 = __toESM(require_react(), 1);
var useLayoutEffect22 = (globalThis == null ? void 0 : globalThis.document) ? React3.useLayoutEffect : () => {
};

// node_modules/@radix-ui/react-use-effect-event/dist/index.mjs
var React4 = __toESM(require_react(), 1);
var useReactEffectEvent = React4[" useEffectEvent ".trim().toString()];
var useReactInsertionEffect = React4[" useInsertionEffect ".trim().toString()];

// node_modules/@strapi/upload/node_modules/@radix-ui/react-use-controllable-state/dist/index.mjs
var useInsertionEffect = React5[" useInsertionEffect ".trim().toString()] || useLayoutEffect2;
function useControllableState({
  prop,
  defaultProp,
  onChange = () => {
  },
  caller
}) {
  const [uncontrolledProp, setUncontrolledProp, onChangeRef] = useUncontrolledState({
    defaultProp,
    onChange
  });
  const isControlled = prop !== void 0;
  const value = isControlled ? prop : uncontrolledProp;
  if (true) {
    const isControlledRef = React5.useRef(prop !== void 0);
    React5.useEffect(() => {
      const wasControlled = isControlledRef.current;
      if (wasControlled !== isControlled) {
        const from = wasControlled ? "controlled" : "uncontrolled";
        const to = isControlled ? "controlled" : "uncontrolled";
        console.warn(
          `${caller} is changing from ${from} to ${to}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`
        );
      }
      isControlledRef.current = isControlled;
    }, [isControlled, caller]);
  }
  const setValue = React5.useCallback(
    (nextValue) => {
      var _a;
      if (isControlled) {
        const value2 = isFunction(nextValue) ? nextValue(prop) : nextValue;
        if (value2 !== prop) {
          (_a = onChangeRef.current) == null ? void 0 : _a.call(onChangeRef, value2);
        }
      } else {
        setUncontrolledProp(nextValue);
      }
    },
    [isControlled, prop, setUncontrolledProp, onChangeRef]
  );
  return [value, setValue];
}
function useUncontrolledState({
  defaultProp,
  onChange
}) {
  const [value, setValue] = React5.useState(defaultProp);
  const prevValueRef = React5.useRef(value);
  const onChangeRef = React5.useRef(onChange);
  useInsertionEffect(() => {
    onChangeRef.current = onChange;
  }, [onChange]);
  React5.useEffect(() => {
    var _a;
    if (prevValueRef.current !== value) {
      (_a = onChangeRef.current) == null ? void 0 : _a.call(onChangeRef, value);
      prevValueRef.current = value;
    }
  }, [value, prevValueRef]);
  return [value, setValue, onChangeRef];
}
function isFunction(value) {
  return typeof value === "function";
}
var SYNC_STATE = Symbol("RADIX:SYNC_STATE");

// node_modules/@strapi/upload/node_modules/@radix-ui/react-primitive/dist/index.mjs
var React8 = __toESM(require_react(), 1);
var ReactDOM = __toESM(require_react_dom(), 1);

// node_modules/@strapi/upload/node_modules/@radix-ui/react-slot/dist/index.mjs
var React7 = __toESM(require_react(), 1);

// node_modules/@strapi/upload/node_modules/@radix-ui/react-compose-refs/dist/index.mjs
var React6 = __toESM(require_react(), 1);
function setRef(ref, value) {
  if (typeof ref === "function") {
    return ref(value);
  } else if (ref !== null && ref !== void 0) {
    ref.current = value;
  }
}
function composeRefs(...refs) {
  return (node) => {
    let hasCleanup = false;
    const cleanups = refs.map((ref) => {
      const cleanup = setRef(ref, node);
      if (!hasCleanup && typeof cleanup == "function") {
        hasCleanup = true;
      }
      return cleanup;
    });
    if (hasCleanup) {
      return () => {
        for (let i = 0; i < cleanups.length; i++) {
          const cleanup = cleanups[i];
          if (typeof cleanup == "function") {
            cleanup();
          } else {
            setRef(refs[i], null);
          }
        }
      };
    }
  };
}
function useComposedRefs(...refs) {
  return React6.useCallback(composeRefs(...refs), refs);
}

// node_modules/@strapi/upload/node_modules/@radix-ui/react-slot/dist/index.mjs
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
function createSlot(ownerName) {
  const SlotClone = createSlotClone(ownerName);
  const Slot2 = React7.forwardRef((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    const childrenArray = React7.Children.toArray(children);
    const slottable = childrenArray.find(isSlottable);
    if (slottable) {
      const newElement = slottable.props.children;
      const newChildren = childrenArray.map((child) => {
        if (child === slottable) {
          if (React7.Children.count(newElement) > 1) return React7.Children.only(null);
          return React7.isValidElement(newElement) ? newElement.props.children : null;
        } else {
          return child;
        }
      });
      return (0, import_jsx_runtime2.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children: React7.isValidElement(newElement) ? React7.cloneElement(newElement, void 0, newChildren) : null });
    }
    return (0, import_jsx_runtime2.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children });
  });
  Slot2.displayName = `${ownerName}.Slot`;
  return Slot2;
}
var Slot = createSlot("Slot");
function createSlotClone(ownerName) {
  const SlotClone = React7.forwardRef((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    if (React7.isValidElement(children)) {
      const childrenRef = getElementRef(children);
      const props2 = mergeProps(slotProps, children.props);
      if (children.type !== React7.Fragment) {
        props2.ref = forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef;
      }
      return React7.cloneElement(children, props2);
    }
    return React7.Children.count(children) > 1 ? React7.Children.only(null) : null;
  });
  SlotClone.displayName = `${ownerName}.SlotClone`;
  return SlotClone;
}
var SLOTTABLE_IDENTIFIER = Symbol("radix.slottable");
function createSlottable(ownerName) {
  const Slottable2 = ({ children }) => {
    return (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children });
  };
  Slottable2.displayName = `${ownerName}.Slottable`;
  Slottable2.__radixId = SLOTTABLE_IDENTIFIER;
  return Slottable2;
}
var Slottable = createSlottable("Slottable");
function isSlottable(child) {
  return React7.isValidElement(child) && typeof child.type === "function" && "__radixId" in child.type && child.type.__radixId === SLOTTABLE_IDENTIFIER;
}
function mergeProps(slotProps, childProps) {
  const overrideProps = { ...childProps };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue) {
        overrideProps[propName] = (...args) => {
          const result = childPropValue(...args);
          slotPropValue(...args);
          return result;
        };
      } else if (slotPropValue) {
        overrideProps[propName] = slotPropValue;
      }
    } else if (propName === "style") {
      overrideProps[propName] = { ...slotPropValue, ...childPropValue };
    } else if (propName === "className") {
      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
    }
  }
  return { ...slotProps, ...overrideProps };
}
function getElementRef(element) {
  var _a, _b;
  let getter = (_a = Object.getOwnPropertyDescriptor(element.props, "ref")) == null ? void 0 : _a.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = (_b = Object.getOwnPropertyDescriptor(element, "ref")) == null ? void 0 : _b.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}

// node_modules/@strapi/upload/node_modules/@radix-ui/react-primitive/dist/index.mjs
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var NODES = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
];
var Primitive = NODES.reduce((primitive, node) => {
  const Slot2 = createSlot(`Primitive.${node}`);
  const Node = React8.forwardRef((props, forwardedRef) => {
    const { asChild, ...primitiveProps } = props;
    const Comp = asChild ? Slot2 : node;
    if (typeof window !== "undefined") {
      window[Symbol.for("radix-ui")] = true;
    }
    return (0, import_jsx_runtime3.jsx)(Comp, { ...primitiveProps, ref: forwardedRef });
  });
  Node.displayName = `Primitive.${node}`;
  return { ...primitive, [node]: Node };
}, {});
function dispatchDiscreteCustomEvent(target, event) {
  if (target) ReactDOM.flushSync(() => target.dispatchEvent(event));
}

// node_modules/@strapi/upload/node_modules/@radix-ui/primitive/dist/index.mjs
var canUseDOM = !!(typeof window !== "undefined" && window.document && window.document.createElement);
function composeEventHandlers(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
  return function handleEvent(event) {
    originalEventHandler == null ? void 0 : originalEventHandler(event);
    if (checkForDefaultPrevented === false || !event.defaultPrevented) {
      return ourEventHandler == null ? void 0 : ourEventHandler(event);
    }
  };
}

// node_modules/@strapi/upload/node_modules/@radix-ui/react-id/dist/index.mjs
var React9 = __toESM(require_react(), 1);
var useReactId = React9[" useId ".trim().toString()] || (() => void 0);
var count = 0;
function useId(deterministicId) {
  const [id, setId] = React9.useState(useReactId());
  useLayoutEffect2(() => {
    if (!deterministicId) setId((reactId) => reactId ?? String(count++));
  }, [deterministicId]);
  return deterministicId || (id ? `radix-${id}` : "");
}

// node_modules/@strapi/upload/node_modules/@radix-ui/react-use-callback-ref/dist/index.mjs
var React10 = __toESM(require_react(), 1);
function useCallbackRef(callback) {
  const callbackRef = React10.useRef(callback);
  React10.useEffect(() => {
    callbackRef.current = callback;
  });
  return React10.useMemo(() => (...args) => {
    var _a;
    return (_a = callbackRef.current) == null ? void 0 : _a.call(callbackRef, ...args);
  }, []);
}

export {
  composeEventHandlers,
  useComposedRefs,
  createContext2,
  createContextScope,
  useLayoutEffect2,
  useId,
  useControllableState,
  createSlot,
  Primitive,
  dispatchDiscreteCustomEvent,
  useCallbackRef,
  closeUploadProgress,
  toggleMinimize,
  cancelUpload,
  uploadProgressReducer,
  abortUpload,
  uploadApi,
  useUploadFilesStreamMutation,
  useRetryCancelledFilesStreamMutation,
  getTranslationKey
};
//# sourceMappingURL=chunk-OM6KIMFX.js.map
