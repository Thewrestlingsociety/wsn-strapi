{
  "version": 3,
  "sources": ["../../../@strapi/upload/admin/src/future/utils/translations.ts", "../../../@strapi/upload/admin/src/future/store/uploadProgress.ts", "../../../@strapi/upload/admin/src/future/services/api.ts", "../../../@strapi/upload/node_modules/@radix-ui/react-context/src/create-context.tsx", "../../../@strapi/upload/node_modules/@radix-ui/react-use-controllable-state/src/use-controllable-state.tsx", "../../../@strapi/upload/node_modules/@radix-ui/react-use-controllable-state/src/use-controllable-state-reducer.tsx", "../../../@strapi/upload/node_modules/@radix-ui/react-use-layout-effect/src/use-layout-effect.tsx", "../../../@radix-ui/react-use-effect-event/node_modules/@radix-ui/react-use-layout-effect/src/use-layout-effect.tsx", "../../../@radix-ui/react-use-effect-event/src/use-effect-event.tsx", "../../../@strapi/upload/node_modules/@radix-ui/react-primitive/src/primitive.tsx", "../../../@strapi/upload/node_modules/@radix-ui/react-slot/src/slot.tsx", "../../../@strapi/upload/node_modules/@radix-ui/react-compose-refs/src/compose-refs.tsx", "../../../@strapi/upload/node_modules/@radix-ui/primitive/src/primitive.tsx", "../../../@strapi/upload/node_modules/@radix-ui/react-id/src/id.tsx", "../../../@strapi/upload/node_modules/@radix-ui/react-use-callback-ref/src/use-callback-ref.tsx"],
  "sourcesContent": ["import { pluginId } from '../../pluginId';\n\nexport const getTranslationKey = (id: string) => `${pluginId}.${id}`;\n", "import { createSlice, type PayloadAction } from '@reduxjs/toolkit';\n\nimport type { File } from '../../../../shared/contracts/files';\n\nexport interface FileUploadError {\n  name: string;\n  message: string;\n}\n\nexport type FileProgressStatus = 'pending' | 'uploading' | 'complete' | 'error' | 'cancelled';\n\nexport interface FileProgress {\n  name: string;\n  index: number;\n  status: FileProgressStatus;\n  size: number;\n  file?: File;\n  error?: string;\n}\n\nexport interface UploadProgressState {\n  isVisible: boolean;\n  isMinimized: boolean;\n  progress: number;\n  totalFiles: number;\n  files: FileProgress[];\n  errors: FileUploadError[];\n  uploadId: number;\n}\n\nexport interface RootState {\n  uploadProgress: UploadProgressState;\n}\n\nconst initialState: UploadProgressState = {\n  isVisible: false,\n  isMinimized: false,\n  progress: 0,\n  totalFiles: 0,\n  files: [],\n  errors: [],\n  uploadId: 0,\n};\n\nconst computeProgress = (files: FileProgress[]): number => {\n  if (files.length === 0) return 0;\n  const totalSize = files.reduce((sum, f) => sum + f.size, 0);\n  if (totalSize === 0) {\n    // Fallback to count-based if sizes are unknown\n    const completed = files.filter(\n      (f) => f.status === 'complete' || f.status === 'error' || f.status === 'cancelled'\n    ).length;\n    return Math.round((completed / files.length) * 100);\n  }\n  const completedSize = files\n    .filter((f) => f.status === 'complete' || f.status === 'error' || f.status === 'cancelled')\n    .reduce((sum, f) => sum + f.size, 0);\n  return Math.round((completedSize / totalSize) * 100);\n};\n\nconst uploadProgressSlice = createSlice({\n  name: 'uploadProgress',\n  initialState,\n  reducers: {\n    openUploadProgress(\n      state,\n      action: PayloadAction<{ totalFiles: number; fileNames: string[]; fileSizes: number[] }>\n    ) {\n      state.isVisible = true;\n      state.isMinimized = false;\n      state.progress = 0;\n      state.totalFiles = action.payload.totalFiles;\n      state.files = action.payload.fileNames.map((name, index) => ({\n        name,\n        index,\n        status: 'pending' as FileProgressStatus,\n        size: action.payload.fileSizes[index] || 0,\n      }));\n      state.errors = [];\n      state.uploadId += 1;\n    },\n    setFileUploading(\n      state,\n      action: PayloadAction<{ name: string; index: number; total: number; size: number }>\n    ) {\n      const { index } = action.payload;\n      if (state.files[index]) {\n        state.files[index].status = 'uploading';\n      }\n    },\n    setFileComplete(state, action: PayloadAction<{ index: number; file: File }>) {\n      const { index, file } = action.payload;\n      if (state.files[index]) {\n        state.files[index].status = 'complete';\n        state.files[index].file = file;\n      }\n      state.progress = computeProgress(state.files);\n    },\n    setFileError(state, action: PayloadAction<{ index: number; name: string; message: string }>) {\n      const { index, name, message } = action.payload;\n      if (state.files[index]) {\n        state.files[index].status = 'error';\n        state.files[index].error = message;\n      }\n      state.errors = [...state.errors, { name, message }];\n      state.progress = computeProgress(state.files);\n    },\n    updateProgress(state, action: PayloadAction<number>) {\n      state.progress = action.payload;\n    },\n    addUploadErrors(state, action: PayloadAction<FileUploadError[]>) {\n      state.errors = [...state.errors, ...action.payload];\n    },\n    closeUploadProgress(state) {\n      state.isVisible = false;\n      state.isMinimized = false;\n      state.progress = 0;\n      state.totalFiles = 0;\n      state.files = [];\n      state.errors = [];\n    },\n    toggleMinimize(state) {\n      state.isMinimized = !state.isMinimized;\n    },\n    cancelUpload(state) {\n      // Mark all pending and uploading files as cancelled\n      state.files = state.files.map((file) => {\n        if (file.status === 'pending' || file.status === 'uploading') {\n          return { ...file, status: 'cancelled' as FileProgressStatus };\n        }\n        return file;\n      });\n      state.progress = computeProgress(state.files);\n    },\n    setUploadFailed(state, action: PayloadAction<{ message: string }>) {\n      // Mark all pending and uploading files as errored when a catastrophic failure occurs\n      state.files = state.files.map((file) => {\n        if (file.status === 'pending' || file.status === 'uploading') {\n          return {\n            ...file,\n            status: 'error' as FileProgressStatus,\n            error: action.payload.message,\n          };\n        }\n        return file;\n      });\n      state.progress = 100;\n      state.errors = [...state.errors, { name: 'Upload Error', message: action.payload.message }];\n    },\n    retryCancelledFiles(state) {\n      // Reset all cancelled files back to pending for retry\n      state.files = state.files.map((file) => {\n        if (file.status === 'cancelled') {\n          return {\n            ...file,\n            status: 'pending' as FileProgressStatus,\n          };\n        }\n        return file;\n      });\n      state.progress = computeProgress(state.files);\n    },\n  },\n});\n\nexport const {\n  openUploadProgress,\n  setFileUploading,\n  setFileComplete,\n  setFileError,\n  updateProgress,\n  addUploadErrors,\n  closeUploadProgress,\n  toggleMinimize,\n  cancelUpload,\n  setUploadFailed,\n  retryCancelledFiles,\n} = uploadProgressSlice.actions;\n\nexport const uploadProgressReducer = uploadProgressSlice.reducer;\n", "import { Dispatch } from '@reduxjs/toolkit';\nimport { adminApi } from '@strapi/admin/strapi-admin';\n\nimport {\n  openUploadProgress,\n  setFileUploading,\n  setFileComplete,\n  setFileError,\n  updateProgress,\n  setUploadFailed,\n  retryCancelledFiles,\n} from '../store/uploadProgress';\n\nimport type {\n  CreateFilesStream,\n  CreateFilesStreamEvents,\n} from '../../../../shared/contracts/files';\n\ninterface UploadFilesArgs {\n  formData: FormData;\n  totalFiles: number;\n}\n\ninterface RootState {\n  admin_app: {\n    token?: string | null;\n  };\n  uploadProgress: {\n    uploadId: number;\n    files: Array<{\n      index: number;\n      name: string;\n      size: number;\n      status: 'pending' | 'uploading' | 'complete' | 'error' | 'cancelled';\n    }>;\n  };\n}\n\n/**\n * Stores original File objects for retry functionality.\n *\n * Similar to abortControllers, File objects cannot be stored in Redux state\n * (they are not serializable). This Map allows us to retry cancelled uploads\n * by retrieving the original files using the uploadId.\n */\nconst uploadedFiles = new Map<number, File[]>();\n\n/**\n * Registers files for a specific upload to enable retry.\n */\nconst registerUploadedFiles = (uploadId: number, files: File[]) => {\n  uploadedFiles.set(uploadId, files);\n};\n\n/**\n * Retrieves stored files for an upload.\n */\nconst getUploadedFiles = (uploadId: number): File[] | undefined => {\n  return uploadedFiles.get(uploadId);\n};\n\n/**\n * Manages abort controllers for in-flight uploads.\n *\n * Design decision: Uses a Map to track uploads by their unique uploadId.\n * This approach is necessary because:\n * 1. Redux state cannot store function references (abort controllers)\n * 2. RTK Query's signal is only accessible within the queryFn\n * 3. The upload is triggered in AssetsPage but cancelled from UploadProgressDialog\n *\n * The uploadId ensures we abort the correct upload even if multiple uploads\n * are queued, though the current UI prevents simultaneous uploads.\n */\nconst abortControllers = new Map<number, AbortController>();\n\n/**\n * Registers an abort controller for a specific upload.\n * Called internally when an upload starts.\n */\nconst registerAbortController = (uploadId: number, controller: AbortController) => {\n  abortControllers.set(uploadId, controller);\n};\n\n/**\n * Removes an abort controller when an upload completes or is aborted.\n */\nconst unregisterAbortController = (uploadId: number) => {\n  abortControllers.delete(uploadId);\n};\n\n/**\n * Aborts an upload by its uploadId.\n * Called from the UploadProgressDialog when the user clicks cancel or close.\n */\nexport const abortUpload = (uploadId: number) => {\n  const controller = abortControllers.get(uploadId);\n  if (controller) {\n    controller.abort();\n    unregisterAbortController(uploadId);\n  }\n};\n\n/**\n * Parses a raw SSE text chunk into event/data pairs.\n *\n * SSE format:\n *   event: <eventName>\\n\n *   data: <json>\\n\n *   \\n\n */\nconst parseSSEEvents = (chunk: string): Array<{ event: string; data: string }> => {\n  const events: Array<{ event: string; data: string }> = [];\n  const blocks = chunk.split('\\n\\n').filter(Boolean);\n\n  for (const block of blocks) {\n    let event = '';\n    let data = '';\n\n    for (const line of block.split('\\n')) {\n      if (line.startsWith('event: ')) {\n        event = line.slice(7);\n      } else if (line.startsWith('data: ')) {\n        data = line.slice(6);\n      }\n    }\n\n    if (event && data) {\n      events.push({ event, data });\n    }\n  }\n\n  return events;\n};\n\n/**\n * Makes a streaming upload request to the server.\n *\n * We use fetch directly instead of RTK Query's fetchBaseQuery because:\n * 1. We need access to the raw Response to read the body as a stream\n * 2. RTK Query's baseQuery awaits the full response and parses it as JSON,\n *    which doesn't work for Server-Sent Events (SSE) streaming\n * 3. The stream must be read incrementally via response.body.getReader()\n *    to dispatch progress updates as files upload\n */\nconst fetchUploadStream = async ({\n  token,\n  formData,\n  signal,\n}: {\n  token: string | null | undefined;\n  formData: FormData;\n  signal: AbortSignal;\n}): Promise<Response> => {\n  const backendURL = window.strapi.backendURL;\n  const headers: Record<string, string> = {};\n  if (token) {\n    headers.Authorization = `Bearer ${token}`;\n  }\n\n  return fetch(`${backendURL}/upload/unstable/stream`, {\n    method: 'POST',\n    headers,\n    body: formData,\n    signal,\n  });\n};\n\n/**\n * Options for processing an SSE upload stream.\n */\ninterface ProcessSSEStreamOptions {\n  response: Response;\n  dispatch: Dispatch;\n  indexMapper?: (serverIndex: number) => number;\n}\n\n/**\n * Processes an SSE stream from the upload endpoint.\n * Dispatches Redux actions for each file event and returns the final result.\n *\n * @param options.response - The fetch Response object with SSE body\n * @param options.dispatch - Redux dispatch function\n * @param options.indexMapper - Optional function to map server indices to state indices (for retry)\n * @param options.logPrefix - Optional prefix for console logs\n * @returns The stream result or null if no files completed\n */\nconst processSSEStream = async ({\n  response,\n  dispatch,\n  indexMapper = (i) => i,\n}: ProcessSSEStreamOptions): Promise<CreateFilesStream.Response | null> => {\n  const reader = response.body!.getReader();\n  const decoder = new TextDecoder();\n  let streamResult: CreateFilesStream.Response | null = null;\n  let buffer = '';\n\n  while (true) {\n    const { done, value } = await reader.read();\n\n    if (done) {\n      break;\n    }\n\n    buffer += decoder.decode(value, { stream: true });\n\n    // Process complete SSE events from the buffer\n    const lastDoubleNewline = buffer.lastIndexOf('\\n\\n');\n    if (lastDoubleNewline === -1) {\n      // No complete events yet, keep buffering\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n\n    const completePart = buffer.slice(0, lastDoubleNewline + 2);\n    buffer = buffer.slice(lastDoubleNewline + 2);\n\n    const events = parseSSEEvents(completePart);\n\n    for (const { event, data } of events) {\n      const parsed = JSON.parse(data);\n      const mappedIndex = indexMapper(parsed.index as number);\n\n      switch (event) {\n        case 'file:uploading': {\n          const payload = parsed as CreateFilesStreamEvents.FileUploadingEvent;\n          dispatch(\n            setFileUploading({\n              name: payload.name,\n              index: mappedIndex,\n              total: payload.total,\n              size: payload.size,\n            })\n          );\n          break;\n        }\n        case 'file:complete': {\n          const payload = parsed as CreateFilesStreamEvents.FileCompleteEvent;\n          dispatch(\n            setFileComplete({\n              index: mappedIndex,\n              file: payload.file,\n            })\n          );\n          break;\n        }\n        case 'file:error': {\n          const payload = parsed as CreateFilesStreamEvents.FileErrorEvent;\n          dispatch(\n            setFileError({\n              index: mappedIndex,\n              name: payload.name,\n              message: payload.message,\n            })\n          );\n          break;\n        }\n        case 'stream:complete': {\n          const payload = parsed as CreateFilesStreamEvents.StreamCompleteEvent;\n          streamResult = {\n            data: payload.data,\n            errors: payload.errors,\n          };\n          break;\n        }\n        default:\n          console.error(`[SSE Upload] unknown event: ${event}`, parsed);\n      }\n    }\n  }\n\n  return streamResult;\n};\n\nconst uploadApi = adminApi\n  .enhanceEndpoints({\n    addTagTypes: ['Asset', 'Folder'],\n  })\n  .injectEndpoints({\n    endpoints: (builder) => ({\n      /**\n       * Stream upload files to the /upload/unstable/stream endpoint.\n       * Reads SSE stream for per-file progress updates.\n       */\n      uploadFilesStream: builder.mutation<CreateFilesStream.Response, UploadFilesArgs>({\n        queryFn: async ({ formData, totalFiles }, { dispatch, getState }) => {\n          const token = (getState() as RootState).admin_app?.token;\n\n          // Extract file names and sizes from FormData\n          const files = formData.getAll('files') as File[];\n          const fileInfoJson = formData.get('fileInfo') as string;\n          const fileInfo = JSON.parse(fileInfoJson) as Array<{ name: string }>;\n          const fileNames = fileInfo.map((info) => info.name);\n          const fileSizes = files.map((file) => file.size);\n\n          // Open the progress dialog and get the uploadId\n          dispatch(openUploadProgress({ totalFiles, fileNames, fileSizes }));\n          dispatch(updateProgress(0));\n\n          // Get the uploadId from state after dispatching\n          const uploadId = (getState() as RootState).uploadProgress.uploadId;\n\n          // Store original files for retry functionality\n          registerUploadedFiles(uploadId, files);\n\n          // Create abort controller for this upload\n          const abortController = new AbortController();\n          registerAbortController(uploadId, abortController);\n\n          try {\n            const response = await fetchUploadStream({\n              token,\n              formData,\n              signal: abortController.signal,\n            });\n\n            if (!response.ok || !response.body) {\n              unregisterAbortController(uploadId);\n\n              // Try to parse error message from response\n              let errorMessage = 'Upload request failed';\n              try {\n                const errorData = await response.json();\n                if (errorData.error?.message) {\n                  errorMessage = errorData.error.message;\n                } else if (errorData.message) {\n                  errorMessage = errorData.message;\n                }\n              } catch {\n                // If we can't parse the error, use a generic message with status code\n                errorMessage = `Upload failed with status ${response.status}`;\n              }\n\n              // Mark all files as failed in the UI\n              dispatch(setUploadFailed({ message: errorMessage }));\n\n              return {\n                error: {\n                  name: 'UnknownError',\n                  message: errorMessage,\n                  status: response.status,\n                },\n              };\n            }\n\n            const streamResult = await processSSEStream({\n              response,\n              dispatch,\n            });\n\n            unregisterAbortController(uploadId);\n\n            if (streamResult && streamResult.data.length > 0) {\n              return { data: streamResult };\n            }\n\n            // If stream ended without completing any files, mark all as failed\n            const errorMessage = 'No files were uploaded successfully';\n            dispatch(setUploadFailed({ message: errorMessage }));\n\n            return {\n              error: {\n                name: 'UnknownError',\n                message: errorMessage,\n              },\n            };\n          } catch (err) {\n            unregisterAbortController(uploadId);\n\n            if (err instanceof DOMException && err.name === 'AbortError') {\n              // Don't mark as failed for user-initiated cancellations\n              return {\n                error: { name: 'UnknownError', message: 'Upload cancelled' },\n              };\n            }\n\n            // For network errors or other exceptions, mark all files as failed\n            const errorMessage = err instanceof Error ? err.message : 'Network error occurred';\n            dispatch(setUploadFailed({ message: errorMessage }));\n\n            return {\n              error: {\n                name: 'UnknownError',\n                message: errorMessage,\n              },\n            };\n          }\n        },\n        invalidatesTags: [{ type: 'Asset', id: 'LIST' }],\n      }),\n\n      /**\n       * Retry uploading cancelled files.\n       * Retrieves original File objects and re-uploads only the cancelled ones.\n       */\n      retryCancelledFilesStream: builder.mutation<CreateFilesStream.Response, void>({\n        queryFn: async (_, { dispatch, getState }) => {\n          const token = (getState() as RootState).admin_app?.token;\n          const { uploadId, files: stateFiles } = (getState() as RootState).uploadProgress;\n\n          // Get cancelled files with their original indices\n          const cancelledFiles = stateFiles.filter((f) => f.status === 'cancelled');\n          if (cancelledFiles.length === 0) {\n            return { error: { name: 'UnknownError', message: 'No cancelled files to retry' } };\n          }\n\n          // Get the original File objects\n          const originalFiles = getUploadedFiles(uploadId);\n          if (!originalFiles) {\n            return { error: { name: 'UnknownError', message: 'Original files not found' } };\n          }\n\n          // Build mapping from new index to original index\n          const indexMapping = cancelledFiles.map((f) => f.index);\n          const filesToRetry = cancelledFiles.map((f) => originalFiles[f.index]);\n\n          // Reset cancelled files to pending\n          dispatch(retryCancelledFiles());\n\n          // Build FormData for retry\n          const formData = new FormData();\n          const fileInfoArray = filesToRetry.map((file) => ({\n            name: file.name,\n            caption: null,\n            alternativeText: null,\n            folder: null, // TODO: preserve folder from original upload if needed\n          }));\n\n          filesToRetry.forEach((file) => {\n            formData.append('files', file);\n          });\n          formData.append('fileInfo', JSON.stringify(fileInfoArray));\n\n          // Create abort controller for this retry\n          const abortController = new AbortController();\n          registerAbortController(uploadId, abortController);\n\n          try {\n            const response = await fetchUploadStream({\n              token,\n              formData,\n              signal: abortController.signal,\n            });\n\n            if (!response.ok || !response.body) {\n              unregisterAbortController(uploadId);\n\n              let errorMessage = 'Retry request failed';\n              try {\n                const errorData = await response.json();\n                if (errorData.error?.message) {\n                  errorMessage = errorData.error.message;\n                } else if (errorData.message) {\n                  errorMessage = errorData.message;\n                }\n              } catch {\n                errorMessage = `Retry failed with status ${response.status}`;\n              }\n\n              // Mark retried files as failed\n              for (const originalIndex of indexMapping) {\n                dispatch(\n                  setFileError({\n                    index: originalIndex,\n                    name: stateFiles[originalIndex].name,\n                    message: errorMessage,\n                  })\n                );\n              }\n\n              return {\n                error: {\n                  name: 'UnknownError',\n                  message: errorMessage,\n                  status: response.status,\n                },\n              };\n            }\n\n            const streamResult = await processSSEStream({\n              response,\n              dispatch,\n              indexMapper: (serverIndex) => indexMapping[serverIndex],\n            });\n\n            unregisterAbortController(uploadId);\n\n            if (streamResult && streamResult.data.length > 0) {\n              return { data: streamResult };\n            }\n\n            return {\n              error: {\n                name: 'UnknownError',\n                message: 'No files were uploaded successfully',\n              },\n            };\n          } catch (err) {\n            unregisterAbortController(uploadId);\n\n            if (err instanceof DOMException && err.name === 'AbortError') {\n              return {\n                error: { name: 'UnknownError', message: 'Retry cancelled' },\n              };\n            }\n\n            const errorMessage = err instanceof Error ? err.message : 'Network error occurred';\n            return {\n              error: {\n                name: 'UnknownError',\n                message: errorMessage,\n              },\n            };\n          }\n        },\n        invalidatesTags: [{ type: 'Asset', id: 'LIST' }],\n      }),\n    }),\n  });\n\nexport const { useUploadFilesStreamMutation, useRetryCancelledFilesStreamMutation } = uploadApi;\nexport { uploadApi };\n", "import * as React from 'react';\n\nfunction createContext<ContextValueType extends object | null>(\n  rootComponentName: string,\n  defaultContext?: ContextValueType\n) {\n  const Context = React.createContext<ContextValueType | undefined>(defaultContext);\n\n  const Provider: React.FC<ContextValueType & { children: React.ReactNode }> = (props) => {\n    const { children, ...context } = props;\n    // Only re-memoize when prop values change\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    const value = React.useMemo(() => context, Object.values(context)) as ContextValueType;\n    return <Context.Provider value={value}>{children}</Context.Provider>;\n  };\n\n  Provider.displayName = rootComponentName + 'Provider';\n\n  function useContext(consumerName: string) {\n    const context = React.useContext(Context);\n    if (context) return context;\n    if (defaultContext !== undefined) return defaultContext;\n    // if a defaultContext wasn't specified, it's a required context.\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${rootComponentName}\\``);\n  }\n\n  return [Provider, useContext] as const;\n}\n\n/* -------------------------------------------------------------------------------------------------\n * createContextScope\n * -----------------------------------------------------------------------------------------------*/\n\ntype Scope<C = any> = { [scopeName: string]: React.Context<C>[] } | undefined;\ntype ScopeHook = (scope: Scope) => { [__scopeProp: string]: Scope };\ninterface CreateScope {\n  scopeName: string;\n  (): ScopeHook;\n}\n\nfunction createContextScope(scopeName: string, createContextScopeDeps: CreateScope[] = []) {\n  let defaultContexts: any[] = [];\n\n  /* -----------------------------------------------------------------------------------------------\n   * createContext\n   * ---------------------------------------------------------------------------------------------*/\n\n  function createContext<ContextValueType extends object | null>(\n    rootComponentName: string,\n    defaultContext?: ContextValueType\n  ) {\n    const BaseContext = React.createContext<ContextValueType | undefined>(defaultContext);\n    const index = defaultContexts.length;\n    defaultContexts = [...defaultContexts, defaultContext];\n\n    const Provider: React.FC<\n      ContextValueType & { scope: Scope<ContextValueType>; children: React.ReactNode }\n    > = (props) => {\n      const { scope, children, ...context } = props;\n      const Context = scope?.[scopeName]?.[index] || BaseContext;\n      // Only re-memoize when prop values change\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      const value = React.useMemo(() => context, Object.values(context)) as ContextValueType;\n      return <Context.Provider value={value}>{children}</Context.Provider>;\n    };\n\n    Provider.displayName = rootComponentName + 'Provider';\n\n    function useContext(consumerName: string, scope: Scope<ContextValueType | undefined>) {\n      const Context = scope?.[scopeName]?.[index] || BaseContext;\n      const context = React.useContext(Context);\n      if (context) return context;\n      if (defaultContext !== undefined) return defaultContext;\n      // if a defaultContext wasn't specified, it's a required context.\n      throw new Error(`\\`${consumerName}\\` must be used within \\`${rootComponentName}\\``);\n    }\n\n    return [Provider, useContext] as const;\n  }\n\n  /* -----------------------------------------------------------------------------------------------\n   * createScope\n   * ---------------------------------------------------------------------------------------------*/\n\n  const createScope: CreateScope = () => {\n    const scopeContexts = defaultContexts.map((defaultContext) => {\n      return React.createContext(defaultContext);\n    });\n    return function useScope(scope: Scope) {\n      const contexts = scope?.[scopeName] || scopeContexts;\n      return React.useMemo(\n        () => ({ [`__scope${scopeName}`]: { ...scope, [scopeName]: contexts } }),\n        [scope, contexts]\n      );\n    };\n  };\n\n  createScope.scopeName = scopeName;\n  return [createContext, composeContextScopes(createScope, ...createContextScopeDeps)] as const;\n}\n\n/* -------------------------------------------------------------------------------------------------\n * composeContextScopes\n * -----------------------------------------------------------------------------------------------*/\n\nfunction composeContextScopes(...scopes: CreateScope[]) {\n  const baseScope = scopes[0];\n  if (scopes.length === 1) return baseScope;\n\n  const createScope: CreateScope = () => {\n    const scopeHooks = scopes.map((createScope) => ({\n      useScope: createScope(),\n      scopeName: createScope.scopeName,\n    }));\n\n    return function useComposedScopes(overrideScopes) {\n      const nextScopes = scopeHooks.reduce((nextScopes, { useScope, scopeName }) => {\n        // We are calling a hook inside a callback which React warns against to avoid inconsistent\n        // renders, however, scoping doesn't have render side effects so we ignore the rule.\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        const scopeProps = useScope(overrideScopes);\n        const currentScope = scopeProps[`__scope${scopeName}`];\n        return { ...nextScopes, ...currentScope };\n      }, {});\n\n      return React.useMemo(() => ({ [`__scope${baseScope.scopeName}`]: nextScopes }), [nextScopes]);\n    };\n  };\n\n  createScope.scopeName = baseScope.scopeName;\n  return createScope;\n}\n\n/* -----------------------------------------------------------------------------------------------*/\n\nexport { createContext, createContextScope };\nexport type { CreateScope, Scope };\n", "import * as React from 'react';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\n\n// Prevent bundlers from trying to optimize the import\nconst useInsertionEffect: typeof useLayoutEffect =\n  (React as any)[' useInsertionEffect '.trim().toString()] || useLayoutEffect;\n\ntype ChangeHandler<T> = (state: T) => void;\ntype SetStateFn<T> = React.Dispatch<React.SetStateAction<T>>;\n\ninterface UseControllableStateParams<T> {\n  prop?: T | undefined;\n  defaultProp: T;\n  onChange?: ChangeHandler<T>;\n  caller?: string;\n}\n\nexport function useControllableState<T>({\n  prop,\n  defaultProp,\n  onChange = () => {},\n  caller,\n}: UseControllableStateParams<T>): [T, SetStateFn<T>] {\n  const [uncontrolledProp, setUncontrolledProp, onChangeRef] = useUncontrolledState({\n    defaultProp,\n    onChange,\n  });\n  const isControlled = prop !== undefined;\n  const value = isControlled ? prop : uncontrolledProp;\n\n  // OK to disable conditionally calling hooks here because they will always run\n  // consistently in the same environment. Bundlers should be able to remove the\n  // code block entirely in production.\n  /* eslint-disable react-hooks/rules-of-hooks */\n  if (process.env.NODE_ENV !== 'production') {\n    const isControlledRef = React.useRef(prop !== undefined);\n    React.useEffect(() => {\n      const wasControlled = isControlledRef.current;\n      if (wasControlled !== isControlled) {\n        const from = wasControlled ? 'controlled' : 'uncontrolled';\n        const to = isControlled ? 'controlled' : 'uncontrolled';\n        console.warn(\n          `${caller} is changing from ${from} to ${to}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`\n        );\n      }\n      isControlledRef.current = isControlled;\n    }, [isControlled, caller]);\n  }\n  /* eslint-enable react-hooks/rules-of-hooks */\n\n  const setValue = React.useCallback<SetStateFn<T>>(\n    (nextValue) => {\n      if (isControlled) {\n        const value = isFunction(nextValue) ? nextValue(prop) : nextValue;\n        if (value !== prop) {\n          onChangeRef.current?.(value);\n        }\n      } else {\n        setUncontrolledProp(nextValue);\n      }\n    },\n    [isControlled, prop, setUncontrolledProp, onChangeRef]\n  );\n\n  return [value, setValue];\n}\n\nfunction useUncontrolledState<T>({\n  defaultProp,\n  onChange,\n}: Omit<UseControllableStateParams<T>, 'prop'>): [\n  Value: T,\n  setValue: React.Dispatch<React.SetStateAction<T>>,\n  OnChangeRef: React.RefObject<ChangeHandler<T> | undefined>,\n] {\n  const [value, setValue] = React.useState(defaultProp);\n  const prevValueRef = React.useRef(value);\n\n  const onChangeRef = React.useRef(onChange);\n  useInsertionEffect(() => {\n    onChangeRef.current = onChange;\n  }, [onChange]);\n\n  React.useEffect(() => {\n    if (prevValueRef.current !== value) {\n      onChangeRef.current?.(value);\n      prevValueRef.current = value;\n    }\n  }, [value, prevValueRef]);\n\n  return [value, setValue, onChangeRef];\n}\n\nfunction isFunction(value: unknown): value is (...args: any[]) => any {\n  return typeof value === 'function';\n}\n", "import * as React from 'react';\nimport { useEffectEvent } from '@radix-ui/react-use-effect-event';\n\ntype ChangeHandler<T> = (state: T) => void;\n\ninterface UseControllableStateParams<T> {\n  prop: T | undefined;\n  defaultProp: T;\n  onChange: ChangeHandler<T> | undefined;\n  caller: string;\n}\n\ninterface AnyAction {\n  type: string;\n}\n\nconst SYNC_STATE = Symbol('RADIX:SYNC_STATE');\n\ninterface SyncStateAction<T> {\n  type: typeof SYNC_STATE;\n  state: T;\n}\n\nexport function useControllableStateReducer<T, S extends {}, A extends AnyAction>(\n  reducer: (prevState: S & { state: T }, action: A) => S & { state: T },\n  userArgs: UseControllableStateParams<T>,\n  initialState: S\n): [S & { state: T }, React.Dispatch<A>];\n\nexport function useControllableStateReducer<T, S extends {}, I, A extends AnyAction>(\n  reducer: (prevState: S & { state: T }, action: A) => S & { state: T },\n  userArgs: UseControllableStateParams<T>,\n  initialArg: I,\n  init: (i: I & { state: T }) => S\n): [S & { state: T }, React.Dispatch<A>];\n\nexport function useControllableStateReducer<T, S extends {}, A extends AnyAction>(\n  reducer: (prevState: S & { state: T }, action: A) => S & { state: T },\n  userArgs: UseControllableStateParams<T>,\n  initialArg: any,\n  init?: (i: any) => Omit<S, 'state'>\n): [S & { state: T }, React.Dispatch<A>] {\n  const { prop: controlledState, defaultProp, onChange: onChangeProp, caller } = userArgs;\n  const isControlled = controlledState !== undefined;\n\n  const onChange = useEffectEvent(onChangeProp);\n\n  // OK to disable conditionally calling hooks here because they will always run\n  // consistently in the same environment. Bundlers should be able to remove the\n  // code block entirely in production.\n  /* eslint-disable react-hooks/rules-of-hooks */\n  if (process.env.NODE_ENV !== 'production') {\n    const isControlledRef = React.useRef(controlledState !== undefined);\n    React.useEffect(() => {\n      const wasControlled = isControlledRef.current;\n      if (wasControlled !== isControlled) {\n        const from = wasControlled ? 'controlled' : 'uncontrolled';\n        const to = isControlled ? 'controlled' : 'uncontrolled';\n        console.warn(\n          `${caller} is changing from ${from} to ${to}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`\n        );\n      }\n      isControlledRef.current = isControlled;\n    }, [isControlled, caller]);\n  }\n  /* eslint-enable react-hooks/rules-of-hooks */\n\n  type InternalState = S & { state: T };\n  const args: [InternalState] = [{ ...initialArg, state: defaultProp }];\n  if (init) {\n    // @ts-expect-error\n    args.push(init);\n  }\n\n  const [internalState, dispatch] = React.useReducer(\n    (state: InternalState, action: A | SyncStateAction<T>): InternalState => {\n      if (action.type === SYNC_STATE) {\n        return { ...state, state: action.state };\n      }\n\n      const next = reducer(state, action);\n      if (isControlled && !Object.is(next.state, state.state)) {\n        onChange(next.state);\n      }\n      return next;\n    },\n    ...args\n  );\n\n  const uncontrolledState = internalState.state;\n  const prevValueRef = React.useRef(uncontrolledState);\n  React.useEffect(() => {\n    if (prevValueRef.current !== uncontrolledState) {\n      prevValueRef.current = uncontrolledState;\n      if (!isControlled) {\n        onChange(uncontrolledState);\n      }\n    }\n  }, [onChange, uncontrolledState, prevValueRef, isControlled]);\n\n  const state = React.useMemo(() => {\n    const isControlled = controlledState !== undefined;\n    if (isControlled) {\n      return { ...internalState, state: controlledState };\n    }\n\n    return internalState;\n  }, [internalState, controlledState]);\n\n  React.useEffect(() => {\n    // Sync internal state for controlled components so that reducer is called\n    // with the correct state values\n    if (isControlled && !Object.is(controlledState, internalState.state)) {\n      dispatch({ type: SYNC_STATE, state: controlledState });\n    }\n  }, [controlledState, internalState.state, isControlled]);\n\n  return [state, dispatch as React.Dispatch<A>];\n}\n", "import * as React from 'react';\n\n/**\n * On the server, React emits a warning when calling `useLayoutEffect`.\n * This is because neither `useLayoutEffect` nor `useEffect` run on the server.\n * We use this safe version which suppresses the warning by replacing it with a noop on the server.\n *\n * See: https://reactjs.org/docs/hooks-reference.html#uselayouteffect\n */\nconst useLayoutEffect = globalThis?.document ? React.useLayoutEffect : () => {};\n\nexport { useLayoutEffect };\n", "import * as React from 'react';\n\n/**\n * On the server, React emits a warning when calling `useLayoutEffect`.\n * This is because neither `useLayoutEffect` nor `useEffect` run on the server.\n * We use this safe version which suppresses the warning by replacing it with a noop on the server.\n *\n * See: https://reactjs.org/docs/hooks-reference.html#uselayouteffect\n */\nconst useLayoutEffect = globalThis?.document ? React.useLayoutEffect : () => {};\n\nexport { useLayoutEffect };\n", "/* eslint-disable react-hooks/rules-of-hooks */\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\nimport * as React from 'react';\n\ntype AnyFunction = (...args: any[]) => any;\n\n// See https://github.com/webpack/webpack/issues/14814\nconst useReactEffectEvent = (React as any)[' useEffectEvent '.trim().toString()];\nconst useReactInsertionEffect = (React as any)[' useInsertionEffect '.trim().toString()];\n\n/**\n * Designed to approximate the behavior on `experimental_useEffectEvent` as best\n * as possible until its stable release, and back-fill it as a shim as needed.\n */\nexport function useEffectEvent<T extends AnyFunction>(callback?: T): T {\n  if (typeof useReactEffectEvent === 'function') {\n    return useReactEffectEvent(callback);\n  }\n\n  const ref = React.useRef<AnyFunction | undefined>(() => {\n    throw new Error('Cannot call an event handler while rendering.');\n  });\n  // See https://github.com/webpack/webpack/issues/14814\n  if (typeof useReactInsertionEffect === 'function') {\n    useReactInsertionEffect(() => {\n      ref.current = callback;\n    });\n  } else {\n    useLayoutEffect(() => {\n      ref.current = callback;\n    });\n  }\n\n  // https://github.com/facebook/react/issues/19240\n  return React.useMemo(() => ((...args) => ref.current?.(...args)) as T, []);\n}\n", "import * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport { createSlot } from '@radix-ui/react-slot';\n\nconst NODES = [\n  'a',\n  'button',\n  'div',\n  'form',\n  'h2',\n  'h3',\n  'img',\n  'input',\n  'label',\n  'li',\n  'nav',\n  'ol',\n  'p',\n  'select',\n  'span',\n  'svg',\n  'ul',\n] as const;\n\ntype Primitives = { [E in (typeof NODES)[number]]: PrimitiveForwardRefComponent<E> };\ntype PrimitivePropsWithRef<E extends React.ElementType> = React.ComponentPropsWithRef<E> & {\n  asChild?: boolean;\n};\n\ninterface PrimitiveForwardRefComponent<E extends React.ElementType>\n  extends React.ForwardRefExoticComponent<PrimitivePropsWithRef<E>> {}\n\n/* -------------------------------------------------------------------------------------------------\n * Primitive\n * -----------------------------------------------------------------------------------------------*/\n\nconst Primitive = NODES.reduce((primitive, node) => {\n  const Slot = createSlot(`Primitive.${node}`);\n  const Node = React.forwardRef((props: PrimitivePropsWithRef<typeof node>, forwardedRef: any) => {\n    const { asChild, ...primitiveProps } = props;\n    const Comp: any = asChild ? Slot : node;\n\n    if (typeof window !== 'undefined') {\n      (window as any)[Symbol.for('radix-ui')] = true;\n    }\n\n    return <Comp {...primitiveProps} ref={forwardedRef} />;\n  });\n\n  Node.displayName = `Primitive.${node}`;\n\n  return { ...primitive, [node]: Node };\n}, {} as Primitives);\n\n/* -------------------------------------------------------------------------------------------------\n * Utils\n * -----------------------------------------------------------------------------------------------*/\n\n/**\n * Flush custom event dispatch\n * https://github.com/radix-ui/primitives/pull/1378\n *\n * React batches *all* event handlers since version 18, this introduces certain considerations when using custom event types.\n *\n * Internally, React prioritises events in the following order:\n *  - discrete\n *  - continuous\n *  - default\n *\n * https://github.com/facebook/react/blob/a8a4742f1c54493df00da648a3f9d26e3db9c8b5/packages/react-dom/src/events/ReactDOMEventListener.js#L294-L350\n *\n * `discrete` is an  important distinction as updates within these events are applied immediately.\n * React however, is not able to infer the priority of custom event types due to how they are detected internally.\n * Because of this, it's possible for updates from custom events to be unexpectedly batched when\n * dispatched by another `discrete` event.\n *\n * In order to ensure that updates from custom events are applied predictably, we need to manually flush the batch.\n * This utility should be used when dispatching a custom event from within another `discrete` event, this utility\n * is not necessary when dispatching known event types, or if dispatching a custom type inside a non-discrete event.\n * For example:\n *\n * dispatching a known click \uD83D\uDC4E\n * target.dispatchEvent(new Event(\u2018click\u2019))\n *\n * dispatching a custom type within a non-discrete event \uD83D\uDC4E\n * onScroll={(event) => event.target.dispatchEvent(new CustomEvent(\u2018customType\u2019))}\n *\n * dispatching a custom type within a `discrete` event \uD83D\uDC4D\n * onPointerDown={(event) => dispatchDiscreteCustomEvent(event.target, new CustomEvent(\u2018customType\u2019))}\n *\n * Note: though React classifies `focus`, `focusin` and `focusout` events as `discrete`, it's  not recommended to use\n * this utility with them. This is because it's possible for those handlers to be called implicitly during render\n * e.g. when focus is within a component as it is unmounted, or when managing focus on mount.\n */\n\nfunction dispatchDiscreteCustomEvent<E extends CustomEvent>(target: E['target'], event: E) {\n  if (target) ReactDOM.flushSync(() => target.dispatchEvent(event));\n}\n\n/* -----------------------------------------------------------------------------------------------*/\n\nconst Root = Primitive;\n\nexport {\n  Primitive,\n  //\n  Root,\n  //\n  dispatchDiscreteCustomEvent,\n};\nexport type { PrimitivePropsWithRef };\n", "import * as React from 'react';\nimport { composeRefs } from '@radix-ui/react-compose-refs';\n\n/* -------------------------------------------------------------------------------------------------\n * Slot\n * -----------------------------------------------------------------------------------------------*/\n\ninterface SlotProps extends React.HTMLAttributes<HTMLElement> {\n  children?: React.ReactNode;\n}\n\n/* @__NO_SIDE_EFFECTS__ */ export function createSlot(ownerName: string) {\n  const SlotClone = createSlotClone(ownerName);\n  const Slot = React.forwardRef<HTMLElement, SlotProps>((props, forwardedRef) => {\n    const { children, ...slotProps } = props;\n    const childrenArray = React.Children.toArray(children);\n    const slottable = childrenArray.find(isSlottable);\n\n    if (slottable) {\n      // the new element to render is the one passed as a child of `Slottable`\n      const newElement = slottable.props.children;\n\n      const newChildren = childrenArray.map((child) => {\n        if (child === slottable) {\n          // because the new element will be the one rendered, we are only interested\n          // in grabbing its children (`newElement.props.children`)\n          if (React.Children.count(newElement) > 1) return React.Children.only(null);\n          return React.isValidElement(newElement)\n            ? (newElement.props as { children: React.ReactNode }).children\n            : null;\n        } else {\n          return child;\n        }\n      });\n\n      return (\n        <SlotClone {...slotProps} ref={forwardedRef}>\n          {React.isValidElement(newElement)\n            ? React.cloneElement(newElement, undefined, newChildren)\n            : null}\n        </SlotClone>\n      );\n    }\n\n    return (\n      <SlotClone {...slotProps} ref={forwardedRef}>\n        {children}\n      </SlotClone>\n    );\n  });\n\n  Slot.displayName = `${ownerName}.Slot`;\n  return Slot;\n}\n\nconst Slot = createSlot('Slot');\n\n/* -------------------------------------------------------------------------------------------------\n * SlotClone\n * -----------------------------------------------------------------------------------------------*/\n\ninterface SlotCloneProps {\n  children: React.ReactNode;\n}\n\n/* @__NO_SIDE_EFFECTS__ */ function createSlotClone(ownerName: string) {\n  const SlotClone = React.forwardRef<any, SlotCloneProps>((props, forwardedRef) => {\n    const { children, ...slotProps } = props;\n\n    if (React.isValidElement(children)) {\n      const childrenRef = getElementRef(children);\n      const props = mergeProps(slotProps, children.props as AnyProps);\n      // do not pass ref to React.Fragment for React 19 compatibility\n      if (children.type !== React.Fragment) {\n        props.ref = forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef;\n      }\n      return React.cloneElement(children, props);\n    }\n\n    return React.Children.count(children) > 1 ? React.Children.only(null) : null;\n  });\n\n  SlotClone.displayName = `${ownerName}.SlotClone`;\n  return SlotClone;\n}\n\n/* -------------------------------------------------------------------------------------------------\n * Slottable\n * -----------------------------------------------------------------------------------------------*/\n\nconst SLOTTABLE_IDENTIFIER = Symbol('radix.slottable');\n\ninterface SlottableProps {\n  children: React.ReactNode;\n}\n\ninterface SlottableComponent extends React.FC<SlottableProps> {\n  __radixId: symbol;\n}\n\n/* @__NO_SIDE_EFFECTS__ */ export function createSlottable(ownerName: string) {\n  const Slottable: SlottableComponent = ({ children }) => {\n    return <>{children}</>;\n  };\n  Slottable.displayName = `${ownerName}.Slottable`;\n  Slottable.__radixId = SLOTTABLE_IDENTIFIER;\n  return Slottable;\n}\n\nconst Slottable = createSlottable('Slottable');\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype AnyProps = Record<string, any>;\n\nfunction isSlottable(\n  child: React.ReactNode\n): child is React.ReactElement<SlottableProps, typeof Slottable> {\n  return (\n    React.isValidElement(child) &&\n    typeof child.type === 'function' &&\n    '__radixId' in child.type &&\n    child.type.__radixId === SLOTTABLE_IDENTIFIER\n  );\n}\n\nfunction mergeProps(slotProps: AnyProps, childProps: AnyProps) {\n  // all child props should override\n  const overrideProps = { ...childProps };\n\n  for (const propName in childProps) {\n    const slotPropValue = slotProps[propName];\n    const childPropValue = childProps[propName];\n\n    const isHandler = /^on[A-Z]/.test(propName);\n    if (isHandler) {\n      // if the handler exists on both, we compose them\n      if (slotPropValue && childPropValue) {\n        overrideProps[propName] = (...args: unknown[]) => {\n          const result = childPropValue(...args);\n          slotPropValue(...args);\n          return result;\n        };\n      }\n      // but if it exists only on the slot, we use only this one\n      else if (slotPropValue) {\n        overrideProps[propName] = slotPropValue;\n      }\n    }\n    // if it's `style`, we merge them\n    else if (propName === 'style') {\n      overrideProps[propName] = { ...slotPropValue, ...childPropValue };\n    } else if (propName === 'className') {\n      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(' ');\n    }\n  }\n\n  return { ...slotProps, ...overrideProps };\n}\n\n// Before React 19 accessing `element.props.ref` will throw a warning and suggest using `element.ref`\n// After React 19 accessing `element.ref` does the opposite.\n// https://github.com/facebook/react/pull/28348\n//\n// Access the ref using the method that doesn't yield a warning.\nfunction getElementRef(element: React.ReactElement) {\n  // React <=18 in DEV\n  let getter = Object.getOwnPropertyDescriptor(element.props, 'ref')?.get;\n  let mayWarn = getter && 'isReactWarning' in getter && getter.isReactWarning;\n  if (mayWarn) {\n    return (element as any).ref;\n  }\n\n  // React 19 in DEV\n  getter = Object.getOwnPropertyDescriptor(element, 'ref')?.get;\n  mayWarn = getter && 'isReactWarning' in getter && getter.isReactWarning;\n  if (mayWarn) {\n    return (element.props as { ref?: React.Ref<unknown> }).ref;\n  }\n\n  // Not DEV\n  return (element.props as { ref?: React.Ref<unknown> }).ref || (element as any).ref;\n}\n\nexport {\n  Slot,\n  Slottable,\n  //\n  Slot as Root,\n};\nexport type { SlotProps };\n", "import * as React from 'react';\n\ntype PossibleRef<T> = React.Ref<T> | undefined;\n\n/**\n * Set a given ref to a given value\n * This utility takes care of different types of refs: callback refs and RefObject(s)\n */\nfunction setRef<T>(ref: PossibleRef<T>, value: T) {\n  if (typeof ref === 'function') {\n    return ref(value);\n  } else if (ref !== null && ref !== undefined) {\n    ref.current = value;\n  }\n}\n\n/**\n * A utility to compose multiple refs together\n * Accepts callback refs and RefObject(s)\n */\nfunction composeRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  return (node) => {\n    let hasCleanup = false;\n    const cleanups = refs.map((ref) => {\n      const cleanup = setRef(ref, node);\n      if (!hasCleanup && typeof cleanup == 'function') {\n        hasCleanup = true;\n      }\n      return cleanup;\n    });\n\n    // React <19 will log an error to the console if a callback ref returns a\n    // value. We don't use ref cleanups internally so this will only happen if a\n    // user's ref callback returns a value, which we only expect if they are\n    // using the cleanup functionality added in React 19.\n    if (hasCleanup) {\n      return () => {\n        for (let i = 0; i < cleanups.length; i++) {\n          const cleanup = cleanups[i];\n          if (typeof cleanup == 'function') {\n            cleanup();\n          } else {\n            setRef(refs[i], null);\n          }\n        }\n      };\n    }\n  };\n}\n\n/**\n * A custom hook that composes multiple refs\n * Accepts callback refs and RefObject(s)\n */\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  return React.useCallback(composeRefs(...refs), refs);\n}\n\nexport { composeRefs, useComposedRefs };\n", "/* eslint-disable no-restricted-properties */\n\n/* eslint-disable no-restricted-globals */\nexport const canUseDOM = !!(\n  typeof window !== 'undefined' &&\n  window.document &&\n  window.document.createElement\n);\n/* eslint-enable no-restricted-globals */\n\nexport function composeEventHandlers<E extends { defaultPrevented: boolean }>(\n  originalEventHandler?: (event: E) => void,\n  ourEventHandler?: (event: E) => void,\n  { checkForDefaultPrevented = true } = {}\n) {\n  return function handleEvent(event: E) {\n    originalEventHandler?.(event);\n\n    if (checkForDefaultPrevented === false || !event.defaultPrevented) {\n      return ourEventHandler?.(event);\n    }\n  };\n}\n\nexport function getOwnerWindow(element: Node | null | undefined) {\n  if (!canUseDOM) {\n    throw new Error('Cannot access window outside of the DOM');\n  }\n  // eslint-disable-next-line no-restricted-globals\n  return element?.ownerDocument?.defaultView ?? window;\n}\n\nexport function getOwnerDocument(element: Node | null | undefined) {\n  if (!canUseDOM) {\n    throw new Error('Cannot access document outside of the DOM');\n  }\n  // eslint-disable-next-line no-restricted-globals\n  return element?.ownerDocument ?? document;\n}\n\n/**\n * Lifted from https://github.com/ariakit/ariakit/blob/main/packages/ariakit-core/src/utils/dom.ts#L37\n * MIT License, Copyright (c) AriaKit.\n */\nexport function getActiveElement(\n  node: Node | null | undefined,\n  activeDescendant = false\n): HTMLElement | null {\n  const { activeElement } = getOwnerDocument(node);\n  if (!activeElement?.nodeName) {\n    // `activeElement` might be an empty object if we're interacting with elements\n    // inside of an iframe.\n    return null;\n  }\n\n  if (isFrame(activeElement) && activeElement.contentDocument) {\n    return getActiveElement(activeElement.contentDocument.body, activeDescendant);\n  }\n\n  if (activeDescendant) {\n    const id = activeElement.getAttribute('aria-activedescendant');\n    if (id) {\n      const element = getOwnerDocument(activeElement).getElementById(id);\n      if (element) {\n        return element;\n      }\n    }\n  }\n\n  return activeElement as HTMLElement | null;\n}\n\nexport function isFrame(element: Element): element is HTMLIFrameElement {\n  return element.tagName === 'IFRAME';\n}\n", "import * as React from 'react';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\n\n// We spaces with `.trim().toString()` to prevent bundlers from trying to `import { useId } from 'react';`\nconst useReactId = (React as any)[' useId '.trim().toString()] || (() => undefined);\nlet count = 0;\n\nfunction useId(deterministicId?: string): string {\n  const [id, setId] = React.useState<string | undefined>(useReactId());\n  // React versions older than 18 will have client-side ids only.\n  useLayoutEffect(() => {\n    if (!deterministicId) setId((reactId) => reactId ?? String(count++));\n  }, [deterministicId]);\n  return deterministicId || (id ? `radix-${id}` : '');\n}\n\nexport { useId };\n", "import * as React from 'react';\n\n/**\n * A custom hook that converts a callback to a ref to avoid triggering re-renders when passed as a\n * prop or avoid re-executing effects when passed as a dependency\n */\nfunction useCallbackRef<T extends (...args: any[]) => any>(callback: T | undefined): T {\n  const callbackRef = React.useRef(callback);\n\n  React.useEffect(() => {\n    callbackRef.current = callback;\n  });\n\n  // https://github.com/facebook/react/issues/19240\n  return React.useMemo(() => ((...args) => callbackRef.current?.(...args)) as T, []);\n}\n\nexport { useCallbackRef };\n"],
  "mappings": "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",
  "names": ["getTranslationKey", "id", "pluginId", "initialState", "isVisible", "isMinimized", "progress", "totalFiles", "files", "errors", "uploadId", "computeProgress", "length", "totalSize", "reduce", "sum", "f", "size", "completed", "filter", "status", "Math", "round", "completedSize", "uploadProgressSlice", "createSlice", "name", "reducers", "openUploadProgress", "state", "action", "payload", "fileNames", "map", "index", "fileSizes", "setFileUploading", "setFileComplete", "file", "setFileError", "message", "error", "updateProgress", "addUploadErrors", "closeUploadProgress", "toggleMinimize", "cancelUpload", "setUploadFailed", "retryCancelledFiles", "actions", "uploadProgressReducer", "reducer", "uploadedFiles", "Map", "registerUploadedFiles", "uploadId", "files", "set", "getUploadedFiles", "get", "abortControllers", "registerAbortController", "controller", "unregisterAbortController", "delete", "abortUpload", "abort", "parseSSEEvents", "chunk", "events", "blocks", "split", "filter", "Boolean", "block", "event", "data", "line", "startsWith", "slice", "push", "fetchUploadStream", "token", "formData", "signal", "backendURL", "window", "strapi", "headers", "Authorization", "fetch", "method", "body", "processSSEStream", "response", "dispatch", "indexMapper", "i", "reader", "getReader", "decoder", "TextDecoder", "streamResult", "buffer", "done", "value", "read", "decode", "stream", "lastDoubleNewline", "lastIndexOf", "completePart", "parsed", "JSON", "parse", "mappedIndex", "index", "payload", "setFileUploading", "name", "total", "size", "setFileComplete", "file", "setFileError", "message", "errors", "console", "error", "uploadApi", "adminApi", "enhanceEndpoints", "addTagTypes", "injectEndpoints", "endpoints", "builder", "uploadFilesStream", "mutation", "queryFn", "totalFiles", "getState", "admin_app", "getAll", "fileInfoJson", "fileInfo", "fileNames", "map", "info", "fileSizes", "openUploadProgress", "updateProgress", "uploadProgress", "abortController", "AbortController", "ok", "errorMessage", "errorData", "json", "status", "setUploadFailed", "length", "err", "DOMException", "Error", "invalidatesTags", "type", "id", "retryCancelledFilesStream", "_", "stateFiles", "cancelledFiles", "f", "originalFiles", "indexMapping", "filesToRetry", "retryCancelledFiles", "FormData", "fileInfoArray", "caption", "alternativeText", "folder", "forEach", "append", "stringify", "originalIndex", "serverIndex", "useUploadFilesStreamMutation", "useRetryCancelledFilesStreamMutation", "createContext", "useContext", "createScope", "nextScopes", "React", "React", "useLayoutEffect", "React2", "React", "useLayoutEffect", "React", "React", "value", "React", "React", "React", "import_jsx_runtime", "Slot", "props", "Slottable", "Fragment", "import_jsx_runtime", "Slot", "React", "React", "React"]
}
