'use strict';

var jsxRuntime = require('react/jsx-runtime');
var React = require('react');
var designSystem = require('@strapi/design-system');
var styledComponents = require('styled-components');

/* -------------------------------------------------------------------------------------------------
 * Context
 * -----------------------------------------------------------------------------------------------*/ const UploadDropZoneContext = /*#__PURE__*/ React.createContext(null);
/* -------------------------------------------------------------------------------------------------
 * Components
 * -----------------------------------------------------------------------------------------------*/ const DropZoneWrapper = styledComponents.styled(designSystem.Box)`
  position: relative;
  display: flex;
  flex-direction: column;
  min-height: 100%;
`;
const UploadDropZoneProvider = ({ children, onDrop })=>{
    const [isDragging, setIsDragging] = React.useState(false);
    const dragCounterRef = React.useRef(0);
    const contextValue = {
        isDragging
    };
    React.useEffect(()=>{
        const handleDragEnd = ()=>{
            setIsDragging(false);
            dragCounterRef.current = 0;
        };
        // Handle drag leaving the entire document/window
        const handleDocumentDragLeave = (e)=>{
            // When relatedTarget is null, we're leaving the document entirely
            if (!e.relatedTarget) {
                setIsDragging(false);
                dragCounterRef.current = 0;
            }
        };
        document.addEventListener('dragend', handleDragEnd);
        document.addEventListener('dragleave', handleDocumentDragLeave);
        return ()=>{
            document.removeEventListener('dragend', handleDragEnd);
            document.removeEventListener('dragleave', handleDocumentDragLeave);
        };
    }, []);
    const handleDragEnter = React.useCallback((e)=>{
        e.preventDefault();
        e.stopPropagation();
        dragCounterRef.current += 1;
        if (e.dataTransfer.types.includes('Files')) {
            setIsDragging(true);
        }
    }, []);
    const handleDragLeave = React.useCallback((e)=>{
        e.preventDefault();
        e.stopPropagation();
        dragCounterRef.current -= 1;
        // Only set dragging to false if we've left the dropzone completely
        // (counter reaches 0 or negative)
        if (dragCounterRef.current <= 0) {
            setIsDragging(false);
            dragCounterRef.current = 0;
        }
    }, []);
    const handleDragOver = React.useCallback((e)=>{
        e.preventDefault();
        e.stopPropagation();
        e.dataTransfer.dropEffect = 'copy';
    }, []);
    const handleDrop = React.useCallback((e)=>{
        e.preventDefault();
        e.stopPropagation();
        setIsDragging(false);
        dragCounterRef.current = 0;
        const { files } = e.dataTransfer;
        if (files?.length && onDrop) {
            onDrop(Array.from(files));
        }
    }, [
        onDrop
    ]);
    return /*#__PURE__*/ jsxRuntime.jsx(UploadDropZoneContext.Provider, {
        value: contextValue,
        children: /*#__PURE__*/ jsxRuntime.jsx(DropZoneWrapper, {
            "data-testid": "assets-dropzone",
            onDragEnter: handleDragEnter,
            onDragLeave: handleDragLeave,
            onDragOver: handleDragOver,
            onDrop: handleDrop,
            children: children
        })
    });
};
/* -------------------------------------------------------------------------------------------------
 * Hook
 * -----------------------------------------------------------------------------------------------*/ const useUploadDropZone = ()=>{
    const context = React.useContext(UploadDropZoneContext);
    if (!context) {
        throw new Error('useUploadDropZone must be used within UploadDropZone');
    }
    return {
        isDragging: context.isDragging
    };
};

exports.UploadDropZoneProvider = UploadDropZoneProvider;
exports.useUploadDropZone = useUploadDropZone;
//# sourceMappingURL=UploadDropZoneContext.js.map
