{"version":3,"file":"api.js","sources":["../../../../admin/src/future/services/api.ts"],"sourcesContent":["import { Dispatch } from '@reduxjs/toolkit';\nimport { adminApi } from '@strapi/admin/strapi-admin';\n\nimport {\n  openUploadProgress,\n  setFileUploading,\n  setFileComplete,\n  setFileError,\n  updateProgress,\n  setUploadFailed,\n  retryCancelledFiles,\n} from '../store/uploadProgress';\n\nimport type {\n  CreateFilesStream,\n  CreateFilesStreamEvents,\n} from '../../../../shared/contracts/files';\n\ninterface UploadFilesArgs {\n  formData: FormData;\n  totalFiles: number;\n}\n\ninterface RootState {\n  admin_app: {\n    token?: string | null;\n  };\n  uploadProgress: {\n    uploadId: number;\n    files: Array<{\n      index: number;\n      name: string;\n      size: number;\n      status: 'pending' | 'uploading' | 'complete' | 'error' | 'cancelled';\n    }>;\n  };\n}\n\n/**\n * Stores original File objects for retry functionality.\n *\n * Similar to abortControllers, File objects cannot be stored in Redux state\n * (they are not serializable). This Map allows us to retry cancelled uploads\n * by retrieving the original files using the uploadId.\n */\nconst uploadedFiles = new Map<number, File[]>();\n\n/**\n * Registers files for a specific upload to enable retry.\n */\nconst registerUploadedFiles = (uploadId: number, files: File[]) => {\n  uploadedFiles.set(uploadId, files);\n};\n\n/**\n * Retrieves stored files for an upload.\n */\nconst getUploadedFiles = (uploadId: number): File[] | undefined => {\n  return uploadedFiles.get(uploadId);\n};\n\n/**\n * Manages abort controllers for in-flight uploads.\n *\n * Design decision: Uses a Map to track uploads by their unique uploadId.\n * This approach is necessary because:\n * 1. Redux state cannot store function references (abort controllers)\n * 2. RTK Query's signal is only accessible within the queryFn\n * 3. The upload is triggered in AssetsPage but cancelled from UploadProgressDialog\n *\n * The uploadId ensures we abort the correct upload even if multiple uploads\n * are queued, though the current UI prevents simultaneous uploads.\n */\nconst abortControllers = new Map<number, AbortController>();\n\n/**\n * Registers an abort controller for a specific upload.\n * Called internally when an upload starts.\n */\nconst registerAbortController = (uploadId: number, controller: AbortController) => {\n  abortControllers.set(uploadId, controller);\n};\n\n/**\n * Removes an abort controller when an upload completes or is aborted.\n */\nconst unregisterAbortController = (uploadId: number) => {\n  abortControllers.delete(uploadId);\n};\n\n/**\n * Aborts an upload by its uploadId.\n * Called from the UploadProgressDialog when the user clicks cancel or close.\n */\nexport const abortUpload = (uploadId: number) => {\n  const controller = abortControllers.get(uploadId);\n  if (controller) {\n    controller.abort();\n    unregisterAbortController(uploadId);\n  }\n};\n\n/**\n * Parses a raw SSE text chunk into event/data pairs.\n *\n * SSE format:\n *   event: <eventName>\\n\n *   data: <json>\\n\n *   \\n\n */\nconst parseSSEEvents = (chunk: string): Array<{ event: string; data: string }> => {\n  const events: Array<{ event: string; data: string }> = [];\n  const blocks = chunk.split('\\n\\n').filter(Boolean);\n\n  for (const block of blocks) {\n    let event = '';\n    let data = '';\n\n    for (const line of block.split('\\n')) {\n      if (line.startsWith('event: ')) {\n        event = line.slice(7);\n      } else if (line.startsWith('data: ')) {\n        data = line.slice(6);\n      }\n    }\n\n    if (event && data) {\n      events.push({ event, data });\n    }\n  }\n\n  return events;\n};\n\n/**\n * Makes a streaming upload request to the server.\n *\n * We use fetch directly instead of RTK Query's fetchBaseQuery because:\n * 1. We need access to the raw Response to read the body as a stream\n * 2. RTK Query's baseQuery awaits the full response and parses it as JSON,\n *    which doesn't work for Server-Sent Events (SSE) streaming\n * 3. The stream must be read incrementally via response.body.getReader()\n *    to dispatch progress updates as files upload\n */\nconst fetchUploadStream = async ({\n  token,\n  formData,\n  signal,\n}: {\n  token: string | null | undefined;\n  formData: FormData;\n  signal: AbortSignal;\n}): Promise<Response> => {\n  const backendURL = window.strapi.backendURL;\n  const headers: Record<string, string> = {};\n  if (token) {\n    headers.Authorization = `Bearer ${token}`;\n  }\n\n  return fetch(`${backendURL}/upload/unstable/stream`, {\n    method: 'POST',\n    headers,\n    body: formData,\n    signal,\n  });\n};\n\n/**\n * Options for processing an SSE upload stream.\n */\ninterface ProcessSSEStreamOptions {\n  response: Response;\n  dispatch: Dispatch;\n  indexMapper?: (serverIndex: number) => number;\n}\n\n/**\n * Processes an SSE stream from the upload endpoint.\n * Dispatches Redux actions for each file event and returns the final result.\n *\n * @param options.response - The fetch Response object with SSE body\n * @param options.dispatch - Redux dispatch function\n * @param options.indexMapper - Optional function to map server indices to state indices (for retry)\n * @param options.logPrefix - Optional prefix for console logs\n * @returns The stream result or null if no files completed\n */\nconst processSSEStream = async ({\n  response,\n  dispatch,\n  indexMapper = (i) => i,\n}: ProcessSSEStreamOptions): Promise<CreateFilesStream.Response | null> => {\n  const reader = response.body!.getReader();\n  const decoder = new TextDecoder();\n  let streamResult: CreateFilesStream.Response | null = null;\n  let buffer = '';\n\n  while (true) {\n    const { done, value } = await reader.read();\n\n    if (done) {\n      break;\n    }\n\n    buffer += decoder.decode(value, { stream: true });\n\n    // Process complete SSE events from the buffer\n    const lastDoubleNewline = buffer.lastIndexOf('\\n\\n');\n    if (lastDoubleNewline === -1) {\n      // No complete events yet, keep buffering\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n\n    const completePart = buffer.slice(0, lastDoubleNewline + 2);\n    buffer = buffer.slice(lastDoubleNewline + 2);\n\n    const events = parseSSEEvents(completePart);\n\n    for (const { event, data } of events) {\n      const parsed = JSON.parse(data);\n      const mappedIndex = indexMapper(parsed.index as number);\n\n      switch (event) {\n        case 'file:uploading': {\n          const payload = parsed as CreateFilesStreamEvents.FileUploadingEvent;\n          dispatch(\n            setFileUploading({\n              name: payload.name,\n              index: mappedIndex,\n              total: payload.total,\n              size: payload.size,\n            })\n          );\n          break;\n        }\n        case 'file:complete': {\n          const payload = parsed as CreateFilesStreamEvents.FileCompleteEvent;\n          dispatch(\n            setFileComplete({\n              index: mappedIndex,\n              file: payload.file,\n            })\n          );\n          break;\n        }\n        case 'file:error': {\n          const payload = parsed as CreateFilesStreamEvents.FileErrorEvent;\n          dispatch(\n            setFileError({\n              index: mappedIndex,\n              name: payload.name,\n              message: payload.message,\n            })\n          );\n          break;\n        }\n        case 'stream:complete': {\n          const payload = parsed as CreateFilesStreamEvents.StreamCompleteEvent;\n          streamResult = {\n            data: payload.data,\n            errors: payload.errors,\n          };\n          break;\n        }\n        default:\n          console.error(`[SSE Upload] unknown event: ${event}`, parsed);\n      }\n    }\n  }\n\n  return streamResult;\n};\n\nconst uploadApi = adminApi\n  .enhanceEndpoints({\n    addTagTypes: ['Asset', 'Folder'],\n  })\n  .injectEndpoints({\n    endpoints: (builder) => ({\n      /**\n       * Stream upload files to the /upload/unstable/stream endpoint.\n       * Reads SSE stream for per-file progress updates.\n       */\n      uploadFilesStream: builder.mutation<CreateFilesStream.Response, UploadFilesArgs>({\n        queryFn: async ({ formData, totalFiles }, { dispatch, getState }) => {\n          const token = (getState() as RootState).admin_app?.token;\n\n          // Extract file names and sizes from FormData\n          const files = formData.getAll('files') as File[];\n          const fileInfoJson = formData.get('fileInfo') as string;\n          const fileInfo = JSON.parse(fileInfoJson) as Array<{ name: string }>;\n          const fileNames = fileInfo.map((info) => info.name);\n          const fileSizes = files.map((file) => file.size);\n\n          // Open the progress dialog and get the uploadId\n          dispatch(openUploadProgress({ totalFiles, fileNames, fileSizes }));\n          dispatch(updateProgress(0));\n\n          // Get the uploadId from state after dispatching\n          const uploadId = (getState() as RootState).uploadProgress.uploadId;\n\n          // Store original files for retry functionality\n          registerUploadedFiles(uploadId, files);\n\n          // Create abort controller for this upload\n          const abortController = new AbortController();\n          registerAbortController(uploadId, abortController);\n\n          try {\n            const response = await fetchUploadStream({\n              token,\n              formData,\n              signal: abortController.signal,\n            });\n\n            if (!response.ok || !response.body) {\n              unregisterAbortController(uploadId);\n\n              // Try to parse error message from response\n              let errorMessage = 'Upload request failed';\n              try {\n                const errorData = await response.json();\n                if (errorData.error?.message) {\n                  errorMessage = errorData.error.message;\n                } else if (errorData.message) {\n                  errorMessage = errorData.message;\n                }\n              } catch {\n                // If we can't parse the error, use a generic message with status code\n                errorMessage = `Upload failed with status ${response.status}`;\n              }\n\n              // Mark all files as failed in the UI\n              dispatch(setUploadFailed({ message: errorMessage }));\n\n              return {\n                error: {\n                  name: 'UnknownError',\n                  message: errorMessage,\n                  status: response.status,\n                },\n              };\n            }\n\n            const streamResult = await processSSEStream({\n              response,\n              dispatch,\n            });\n\n            unregisterAbortController(uploadId);\n\n            if (streamResult && streamResult.data.length > 0) {\n              return { data: streamResult };\n            }\n\n            // If stream ended without completing any files, mark all as failed\n            const errorMessage = 'No files were uploaded successfully';\n            dispatch(setUploadFailed({ message: errorMessage }));\n\n            return {\n              error: {\n                name: 'UnknownError',\n                message: errorMessage,\n              },\n            };\n          } catch (err) {\n            unregisterAbortController(uploadId);\n\n            if (err instanceof DOMException && err.name === 'AbortError') {\n              // Don't mark as failed for user-initiated cancellations\n              return {\n                error: { name: 'UnknownError', message: 'Upload cancelled' },\n              };\n            }\n\n            // For network errors or other exceptions, mark all files as failed\n            const errorMessage = err instanceof Error ? err.message : 'Network error occurred';\n            dispatch(setUploadFailed({ message: errorMessage }));\n\n            return {\n              error: {\n                name: 'UnknownError',\n                message: errorMessage,\n              },\n            };\n          }\n        },\n        invalidatesTags: [{ type: 'Asset', id: 'LIST' }],\n      }),\n\n      /**\n       * Retry uploading cancelled files.\n       * Retrieves original File objects and re-uploads only the cancelled ones.\n       */\n      retryCancelledFilesStream: builder.mutation<CreateFilesStream.Response, void>({\n        queryFn: async (_, { dispatch, getState }) => {\n          const token = (getState() as RootState).admin_app?.token;\n          const { uploadId, files: stateFiles } = (getState() as RootState).uploadProgress;\n\n          // Get cancelled files with their original indices\n          const cancelledFiles = stateFiles.filter((f) => f.status === 'cancelled');\n          if (cancelledFiles.length === 0) {\n            return { error: { name: 'UnknownError', message: 'No cancelled files to retry' } };\n          }\n\n          // Get the original File objects\n          const originalFiles = getUploadedFiles(uploadId);\n          if (!originalFiles) {\n            return { error: { name: 'UnknownError', message: 'Original files not found' } };\n          }\n\n          // Build mapping from new index to original index\n          const indexMapping = cancelledFiles.map((f) => f.index);\n          const filesToRetry = cancelledFiles.map((f) => originalFiles[f.index]);\n\n          // Reset cancelled files to pending\n          dispatch(retryCancelledFiles());\n\n          // Build FormData for retry\n          const formData = new FormData();\n          const fileInfoArray = filesToRetry.map((file) => ({\n            name: file.name,\n            caption: null,\n            alternativeText: null,\n            folder: null, // TODO: preserve folder from original upload if needed\n          }));\n\n          filesToRetry.forEach((file) => {\n            formData.append('files', file);\n          });\n          formData.append('fileInfo', JSON.stringify(fileInfoArray));\n\n          // Create abort controller for this retry\n          const abortController = new AbortController();\n          registerAbortController(uploadId, abortController);\n\n          try {\n            const response = await fetchUploadStream({\n              token,\n              formData,\n              signal: abortController.signal,\n            });\n\n            if (!response.ok || !response.body) {\n              unregisterAbortController(uploadId);\n\n              let errorMessage = 'Retry request failed';\n              try {\n                const errorData = await response.json();\n                if (errorData.error?.message) {\n                  errorMessage = errorData.error.message;\n                } else if (errorData.message) {\n                  errorMessage = errorData.message;\n                }\n              } catch {\n                errorMessage = `Retry failed with status ${response.status}`;\n              }\n\n              // Mark retried files as failed\n              for (const originalIndex of indexMapping) {\n                dispatch(\n                  setFileError({\n                    index: originalIndex,\n                    name: stateFiles[originalIndex].name,\n                    message: errorMessage,\n                  })\n                );\n              }\n\n              return {\n                error: {\n                  name: 'UnknownError',\n                  message: errorMessage,\n                  status: response.status,\n                },\n              };\n            }\n\n            const streamResult = await processSSEStream({\n              response,\n              dispatch,\n              indexMapper: (serverIndex) => indexMapping[serverIndex],\n            });\n\n            unregisterAbortController(uploadId);\n\n            if (streamResult && streamResult.data.length > 0) {\n              return { data: streamResult };\n            }\n\n            return {\n              error: {\n                name: 'UnknownError',\n                message: 'No files were uploaded successfully',\n              },\n            };\n          } catch (err) {\n            unregisterAbortController(uploadId);\n\n            if (err instanceof DOMException && err.name === 'AbortError') {\n              return {\n                error: { name: 'UnknownError', message: 'Retry cancelled' },\n              };\n            }\n\n            const errorMessage = err instanceof Error ? err.message : 'Network error occurred';\n            return {\n              error: {\n                name: 'UnknownError',\n                message: errorMessage,\n              },\n            };\n          }\n        },\n        invalidatesTags: [{ type: 'Asset', id: 'LIST' }],\n      }),\n    }),\n  });\n\nexport const { useUploadFilesStreamMutation, useRetryCancelledFilesStreamMutation } = uploadApi;\nexport { uploadApi };\n"],"names":["uploadedFiles","Map","registerUploadedFiles","uploadId","files","set","getUploadedFiles","get","abortControllers","registerAbortController","controller","unregisterAbortController","delete","abortUpload","abort","parseSSEEvents","chunk","events","blocks","split","filter","Boolean","block","event","data","line","startsWith","slice","push","fetchUploadStream","token","formData","signal","backendURL","window","strapi","headers","Authorization","fetch","method","body","processSSEStream","response","dispatch","indexMapper","i","reader","getReader","decoder","TextDecoder","streamResult","buffer","done","value","read","decode","stream","lastDoubleNewline","lastIndexOf","completePart","parsed","JSON","parse","mappedIndex","index","payload","setFileUploading","name","total","size","setFileComplete","file","setFileError","message","errors","console","error","uploadApi","adminApi","enhanceEndpoints","addTagTypes","injectEndpoints","endpoints","builder","uploadFilesStream","mutation","queryFn","totalFiles","getState","admin_app","getAll","fileInfoJson","fileInfo","fileNames","map","info","fileSizes","openUploadProgress","updateProgress","uploadProgress","abortController","AbortController","ok","errorMessage","errorData","json","status","setUploadFailed","length","err","DOMException","Error","invalidatesTags","type","id","retryCancelledFilesStream","_","stateFiles","cancelledFiles","f","originalFiles","indexMapping","filesToRetry","retryCancelledFiles","FormData","fileInfoArray","caption","alternativeText","folder","forEach","append","stringify","originalIndex","serverIndex","useUploadFilesStreamMutation","useRetryCancelledFilesStreamMutation"],"mappings":"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"}