{"version":3,"file":"List.js","sources":["../../../../../../../../admin/src/pages/EditView/components/FormInputs/BlocksInput/Blocks/List.tsx"],"sourcesContent":["import * as React from 'react';\n\nimport { Typography } from '@strapi/design-system';\nimport { BulletList, NumberList } from '@strapi/icons';\nimport { Schema } from '@strapi/types';\nimport { type Text, Editor, Node, Transforms, Path, Element } from 'slate';\nimport { type RenderElementProps, ReactEditor } from 'slate-react';\nimport { styled, type CSSProperties, css } from 'styled-components';\n\nimport { type BlocksStore } from '../BlocksEditor';\nimport { baseHandleConvert } from '../utils/conversions';\nimport { type Block } from '../utils/types';\n\nconst listStyle = css`\n  display: flex;\n  flex-direction: column;\n  gap: ${({ theme }) => theme.spaces[2]};\n  margin-inline-start: ${({ theme }) => theme.spaces[0]};\n  margin-inline-end: ${({ theme }) => theme.spaces[0]};\n  padding-inline-start: ${({ theme }) => theme.spaces[2]};\n\n  ol,\n  ul {\n    margin-block-start: ${({ theme }) => theme.spaces[0]};\n    margin-block-end: ${({ theme }) => theme.spaces[0]};\n  }\n\n  li {\n    margin-inline-start: ${({ theme }) => theme.spaces[3]};\n  }\n`;\n\nconst Orderedlist = styled.ol<{ $listStyleType: CSSProperties['listStyleType'] }>`\n  list-style-type: ${(props) => props.$listStyleType};\n  ${listStyle}\n`;\n\nconst Unorderedlist = styled.ul<{ $listStyleType: CSSProperties['listStyleType'] }>`\n  list-style-type: ${(props) => props.$listStyleType};\n  ${listStyle}\n`;\n\nconst orderedStyles = ['decimal', 'lower-alpha', 'upper-roman'];\nconst unorderedStyles = ['disc', 'circle', 'square'];\n\nconst isListNode = (element: Element): element is Schema.Attribute.ListBlockNode => {\n  return element.type === 'list';\n};\n\nconst List = ({ attributes, children, element }: RenderElementProps) => {\n  if (!isListNode(element)) {\n    return null;\n  }\n\n  // Decide the subsequent style by referencing the given styles according to the format,\n  // allowing for infinite nested lists\n  const listStyles = element.format === 'ordered' ? orderedStyles : unorderedStyles;\n  const nextIndex = (element.indentLevel || 0) % listStyles!.length;\n  const listStyleType = listStyles![nextIndex];\n\n  if (element.format === 'ordered') {\n    return (\n      <Orderedlist $listStyleType={listStyleType} {...attributes}>\n        {children}\n      </Orderedlist>\n    );\n  }\n\n  return (\n    <Unorderedlist $listStyleType={listStyleType} {...attributes}>\n      {children}\n    </Unorderedlist>\n  );\n};\n\nconst replaceListWithEmptyBlock = (editor: Editor, currentListPath: Path) => {\n  // Delete the empty list\n  Transforms.removeNodes(editor, { at: currentListPath });\n\n  if (currentListPath[0] === 0) {\n    // If the list was the only (or first) block element then insert empty paragraph as editor needs default value\n    Transforms.insertNodes(\n      editor,\n      {\n        type: 'paragraph',\n        children: [{ type: 'text', text: '' }],\n      },\n      { at: currentListPath }\n    );\n    Transforms.select(editor, currentListPath);\n  }\n};\n\nconst isText = (node: unknown): node is Text => {\n  return Node.isNode(node) && !Editor.isEditor(node) && node.type === 'text';\n};\n\n/**\n * Common handler for the backspace event on ordered and unordered lists\n */\nconst handleBackspaceKeyOnList = (editor: Editor, event: React.KeyboardEvent<HTMLElement>) => {\n  if (!editor.selection) return;\n\n  const [currentListItem, currentListItemPath] = Editor.parent(editor, editor.selection.anchor);\n  const [currentList, currentListPath] = Editor.parent(editor, currentListItemPath);\n  const isListEmpty =\n    currentList.children.length === 1 &&\n    isText(currentListItem.children[0]) &&\n    currentListItem.children[0].text === '';\n  const isListItemEmpty =\n    currentListItem.children.length === 1 &&\n    isText(currentListItem.children[0]) &&\n    currentListItem.children[0].text === '';\n  const isFocusAtTheBeginningOfAChild =\n    editor.selection.focus.offset === 0 && editor.selection.focus.path.at(-2) === 0;\n\n  if (isListEmpty) {\n    const parentListEntry = Editor.above(editor, {\n      at: currentListPath,\n      match: (node) => !Editor.isEditor(node) && node.type === 'list',\n    });\n    if (!parentListEntry) {\n      event.preventDefault();\n      replaceListWithEmptyBlock(editor, currentListPath);\n    }\n  } else if (isFocusAtTheBeginningOfAChild) {\n    // If the focus is at the beginning of a child node we need to replace it with a paragraph\n    Transforms.liftNodes(editor, {\n      match: (node) => !Editor.isEditor(node) && node.type === 'list-item',\n    });\n    Transforms.setNodes(editor, { type: 'paragraph' });\n  } else if (isListItemEmpty) {\n    const previousEntry = Editor.previous(editor, {\n      at: currentListItemPath,\n    });\n    const nextEntry = Editor.next(editor, {\n      at: currentListItemPath,\n    });\n\n    if (previousEntry && nextEntry) {\n      // If previous and next nodes are lists or list-items, delete empty list item\n      event.preventDefault();\n      Transforms.removeNodes(editor, {\n        at: currentListItemPath,\n      });\n\n      // If previous and next nodes are lists with same format and indent Levels, then merge the nodes\n      const [previousList] = previousEntry;\n      const [nextList] = nextEntry;\n      if (\n        !Editor.isEditor(previousList) &&\n        !isText(previousList) &&\n        isListNode(previousList) &&\n        !Editor.isEditor(nextList) &&\n        !isText(nextList) &&\n        isListNode(nextList)\n      ) {\n        if (\n          previousList.type === 'list' &&\n          nextList.type === 'list' &&\n          previousList.format === nextList.format &&\n          previousList.indentLevel === nextList.indentLevel\n        ) {\n          Transforms.mergeNodes(editor, {\n            at: currentListItemPath,\n          });\n        }\n      }\n    }\n  }\n};\n\n/**\n * Common handler for the enter key on ordered and unordered lists\n */\nconst handleEnterKeyOnList = (editor: Editor) => {\n  const currentListItemEntry = Editor.above(editor, {\n    match: (node) => !Editor.isEditor(node) && node.type === 'list-item',\n  });\n\n  if (!currentListItemEntry || !editor.selection) {\n    return;\n  }\n\n  const [currentListItem, currentListItemPath] = currentListItemEntry;\n  const [currentList, currentListPath] = Editor.parent(editor, currentListItemPath);\n  const isListEmpty =\n    currentList.children.length === 1 &&\n    isText(currentListItem.children[0]) &&\n    currentListItem.children[0].text === '';\n  const isListItemEmpty =\n    currentListItem.children.length === 1 &&\n    isText(currentListItem.children[0]) &&\n    currentListItem.children[0].text === '';\n  const isFocusAtTheBeginningOfAChild =\n    editor.selection.focus.offset === 0 && editor.selection.focus.path.at(-1) === 0;\n\n  if (isListEmpty) {\n    replaceListWithEmptyBlock(editor, currentListPath);\n  } else if (isFocusAtTheBeginningOfAChild && !isListItemEmpty) {\n    // If the focus is at the beginning of a child node, shift below the list item and create a new list-item\n    const currentNode = Editor.above(editor, { at: editor.selection.anchor });\n    Transforms.insertNodes(editor, { type: 'list-item', children: [{ type: 'text', text: '' }] });\n    if (currentNode) {\n      const path = currentNode[1];\n      const updatedPath = [...path.slice(0, -1), path[path.length - 1] + 1];\n      Transforms.select(editor, {\n        anchor: { path: updatedPath.concat(0), offset: 0 },\n        focus: { path: updatedPath.concat(0), offset: 0 },\n      });\n    }\n  } else if (isListItemEmpty) {\n    // Check if there is a list above the current list and shift list-item under it\n    if (\n      !Editor.isEditor(currentList) &&\n      isListNode(currentList) &&\n      currentList?.indentLevel &&\n      currentList.indentLevel > 0\n    ) {\n      const previousIndentLevel = currentList.indentLevel - 1;\n\n      const parentListNodeEntry = Editor.above(editor, {\n        match: (node) =>\n          !Editor.isEditor(node) &&\n          node.type === 'list' &&\n          (node.indentLevel || 0) === previousIndentLevel,\n      });\n\n      if (parentListNodeEntry) {\n        // Get the parent list path and add 1 to it to exit from the current list\n        const modifiedPath = currentListItemPath.slice(0, -1);\n        if (modifiedPath.length > 0) {\n          modifiedPath[modifiedPath.length - 1] += 1;\n        }\n\n        // Shift list-item under parent list\n        Transforms.moveNodes(editor, {\n          at: currentListItemPath,\n          to: modifiedPath,\n        });\n        return;\n      }\n    }\n\n    // Otherwise delete the empty list item and create a new paragraph below the parent list\n    Transforms.removeNodes(editor, { at: currentListItemPath });\n\n    const createdParagraphPath = Path.next(currentListPath);\n    Transforms.insertNodes(\n      editor,\n      {\n        type: 'paragraph',\n        children: [{ type: 'text', text: '' }],\n      },\n      { at: createdParagraphPath }\n    );\n\n    // Move the selection to the newly created paragraph\n    Transforms.select(editor, createdParagraphPath);\n  } else {\n    // Check if the cursor is at the end of the list item\n    const isNodeEnd = Editor.isEnd(editor, editor.selection.anchor, currentListItemPath);\n\n    if (isNodeEnd) {\n      // If there was nothing after the cursor, create a fresh new list item,\n      // in order to avoid carrying over the modifiers from the previous list item\n      Transforms.insertNodes(editor, { type: 'list-item', children: [{ type: 'text', text: '' }] });\n    } else {\n      // If there is something after the cursor, split the current list item,\n      // so that we keep the content and the modifiers\n      Transforms.splitNodes(editor);\n    }\n  }\n};\n\n/**\n * Common handler for converting a node to a list\n */\nconst handleConvertToList = (editor: Editor, format: Block<'list'>['format']) => {\n  const convertedPath = baseHandleConvert<Block<'list-item'>>(editor, { type: 'list-item' });\n\n  if (!convertedPath) return;\n\n  Transforms.wrapNodes(editor, { type: 'list', format, children: [] }, { at: convertedPath });\n};\n\n/**\n * Common handler for the tab key on ordered and unordered lists\n */\nconst handleTabOnList = (editor: Editor) => {\n  const currentListItemEntry = Editor.above(editor, {\n    match: (node) => !Editor.isEditor(node) && node.type === 'list-item',\n  });\n\n  if (!currentListItemEntry || !editor.selection) {\n    return;\n  }\n\n  const [currentListItem, currentListItemPath] = currentListItemEntry;\n  const [currentList] = Editor.parent(editor, currentListItemPath);\n\n  // Skip tabbing if list-item is the first item in the list\n  if (currentListItem === currentList.children[0]) return;\n\n  const currentListItemIndex = currentList.children.findIndex((item) => item === currentListItem);\n  const previousNode = currentList.children[currentListItemIndex - 1];\n\n  // If previous node is a list block then move the list-item under it\n  if (previousNode.type === 'list') {\n    const nodePath = ReactEditor.findPath(editor, previousNode);\n    const insertAtPath = previousNode.children.length;\n\n    Transforms.moveNodes(editor, {\n      at: currentListItemPath,\n      to: nodePath.concat(insertAtPath),\n    });\n    return;\n  }\n\n  if (!Editor.isEditor(currentList) && isListNode(currentList)) {\n    // Wrap list-item with list block on tab\n    Transforms.wrapNodes(editor, {\n      type: 'list',\n      format: currentList.format,\n      indentLevel: (currentList.indentLevel || 0) + 1,\n      children: [],\n    });\n  }\n};\n\n// All that's in common between ordered and unordered list blocks\nconst baseListBlock = {\n  renderElement: (props) => <List {...props} />,\n  isInBlocksSelector: true,\n  handleEnterKey: handleEnterKeyOnList,\n  handleBackspaceKey: handleBackspaceKeyOnList,\n  handleTab: handleTabOnList,\n  isDraggable: (element) => {\n    if (!isListNode(element)) {\n      throw Error();\n    }\n    const indentLevel = element.indentLevel ?? 0;\n    return indentLevel === 0;\n  },\n} satisfies Partial<BlocksStore['list-ordered' | 'list-unordered']>;\n\nconst listBlocks: Pick<BlocksStore, 'list-ordered' | 'list-unordered' | 'list-item'> = {\n  'list-ordered': {\n    ...baseListBlock,\n    label: {\n      id: 'components.Blocks.blocks.orderedList',\n      defaultMessage: 'Numbered list',\n    },\n    icon: NumberList,\n    matchNode: (node) => node.type === 'list' && node.format === 'ordered',\n    handleConvert: (editor) => handleConvertToList(editor, 'ordered'),\n    snippets: ['1.'],\n  },\n  'list-unordered': {\n    ...baseListBlock,\n    label: {\n      id: 'components.Blocks.blocks.unorderedList',\n      defaultMessage: 'Bulleted list',\n    },\n    icon: BulletList,\n    matchNode: (node) => node.type === 'list' && node.format === 'unordered',\n    handleConvert: (editor) => handleConvertToList(editor, 'unordered'),\n    snippets: ['-', '*', '+'],\n  },\n  'list-item': {\n    renderElement: (props) => (\n      <Typography tag=\"li\" {...props.attributes}>\n        {props.children}\n      </Typography>\n    ),\n    // No handleConvert, list items are created when converting to the parent list\n    matchNode: (node) => node.type === 'list-item',\n    isInBlocksSelector: false,\n    dragHandleTopMargin: '-2px',\n    isDraggable: () => false,\n  },\n};\n\nexport { listBlocks };\n"],"names":["listStyle","css","theme","spaces","Orderedlist","styled","ol","props","$listStyleType","Unorderedlist","ul","orderedStyles","unorderedStyles","isListNode","element","type","List","attributes","children","listStyles","format","nextIndex","indentLevel","length","listStyleType","_jsx","replaceListWithEmptyBlock","editor","currentListPath","Transforms","removeNodes","at","insertNodes","text","select","isText","node","Node","isNode","Editor","isEditor","handleBackspaceKeyOnList","event","selection","currentListItem","currentListItemPath","parent","anchor","currentList","isListEmpty","isListItemEmpty","isFocusAtTheBeginningOfAChild","focus","offset","path","parentListEntry","above","match","preventDefault","liftNodes","setNodes","previousEntry","previous","nextEntry","next","previousList","nextList","mergeNodes","handleEnterKeyOnList","currentListItemEntry","currentNode","updatedPath","slice","concat","previousIndentLevel","parentListNodeEntry","modifiedPath","moveNodes","to","createdParagraphPath","Path","isNodeEnd","isEnd","splitNodes","handleConvertToList","convertedPath","baseHandleConvert","wrapNodes","handleTabOnList","currentListItemIndex","findIndex","item","previousNode","nodePath","ReactEditor","findPath","insertAtPath","baseListBlock","renderElement","isInBlocksSelector","handleEnterKey","handleBackspaceKey","handleTab","isDraggable","Error","listBlocks","label","id","defaultMessage","icon","NumberList","matchNode","handleConvert","snippets","BulletList","Typography","tag","dragHandleTopMargin"],"mappings":"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"}