{"version":3,"file":"5.0.0-discard-drafts.js","sources":["../../../src/migrations/database/5.0.0-discard-drafts.ts"],"sourcesContent":["/**\n * Migration overview\n * ===================\n * 1. Create bare draft rows for every published entry, cloning only scalar fields (no relations/components yet).\n *    We do this with a single INSERT … SELECT per content type to avoid touching the document service for every single v4 entry.\n *\n * 2. Rewire all relations so the newly created drafts behave exactly like calling `documentService.discardDraft()`\n *    on every published entry:\n *      - Join-table relations (self, manyToMany, etc.) are copied in bulk.\n *      - Foreign keys (joinColumn relations) are updated so draft rows point to draft targets.\n *      - Component relations are copied while respecting the discard logic: each draft gets its own component instance,\n *        and the component’s relations (including nested components) are remapped to draft targets.\n *\n * 3. Components are duplicated at the database layer (new component rows + join-table rows). We deliberately clone\n *    instead of sharing component IDs so that draft edits don’t mutate published data.\n *\n * Why we do it this way\n * ----------------------\n * • Efficiency: calling the document service per entry would issue several queries per relation/component. The SQL\n *   batches mirror the service’s behavior but execute in O(content types × batches), so the migration scales to\n *   millions of entries.\n\n * • Memory safety: any caches that track per-record information (component parent lookups, clone maps) are scoped to\n *   a single batch of 1,000 entries. Schema-level caches (component metadata, join table names) remain global because\n *   they’re tiny and reused.\n */\n\n/* eslint-disable no-continue */\nimport type { UID } from '@strapi/types';\nimport type { Database, Migration } from '@strapi/database';\nimport { createId } from '@paralleldrive/cuid2';\nimport { contentTypes } from '@strapi/utils';\nimport createDebug from 'debug';\nimport {\n  getComponentJoinTableName,\n  getComponentJoinColumnEntityName,\n  getComponentJoinColumnInverseName,\n  getComponentTypeColumn,\n} from '../../utils/transform-content-types-to-models';\n\ntype DocumentVersion = { documentId: string; locale: string };\ntype Knex = Parameters<Migration['up']>[0];\n\ntype MetadataWithOptionalPrimaryKey = {\n  primaryKey?: string | { columnName?: string; name?: string };\n  attributes?: Record<string, unknown>;\n};\n\nconst DEFAULT_PRIMARY_KEY_COLUMN = 'id';\n\ntype AttributeWithPrimaryFlag = {\n  columnName?: string;\n  column?: {\n    primary?: boolean;\n  };\n};\n\n/**\n * Determines the primary-key column name for a schema, handling the various shapes\n * metadata can take (string, object, attribute flag) and defaulting to `id`.\n */\nconst resolvePrimaryKeyColumn = (meta: MetadataWithOptionalPrimaryKey): string => {\n  const { primaryKey } = meta;\n\n  if (typeof primaryKey === 'string' && primaryKey) {\n    return primaryKey;\n  }\n\n  if (primaryKey && typeof primaryKey === 'object') {\n    const pkObject = primaryKey as { columnName?: string; name?: string };\n\n    const columnName = pkObject.columnName;\n    if (typeof columnName === 'string' && columnName) {\n      return columnName;\n    }\n\n    const name = pkObject.name;\n    if (typeof name === 'string' && name) {\n      return name;\n    }\n  }\n\n  const attributes = meta.attributes ?? {};\n  for (const [attributeName, attribute] of Object.entries(attributes)) {\n    const normalizedAttribute = attribute as AttributeWithPrimaryFlag | undefined;\n\n    if (!normalizedAttribute) {\n      continue;\n    }\n\n    const { column } = normalizedAttribute;\n    if (column?.primary === true) {\n      if (typeof normalizedAttribute.columnName === 'string' && normalizedAttribute.columnName) {\n        return normalizedAttribute.columnName;\n      }\n\n      return attributeName;\n    }\n  }\n\n  return DEFAULT_PRIMARY_KEY_COLUMN;\n};\n\n/**\n * Check if the model has draft and publish enabled.\n */\nconst hasDraftAndPublish = async (trx: Knex, meta: any) => {\n  const hasTable = await trx.schema.hasTable(meta.tableName);\n\n  if (!hasTable) {\n    return false;\n  }\n\n  const uid = meta.uid as UID.ContentType;\n  const model = strapi.getModel(uid);\n  const hasDP = contentTypes.hasDraftAndPublish(model);\n  if (!hasDP) {\n    return false;\n  }\n\n  return true;\n};\n\n/**\n * Copy all the published entries to draft entries, without it's components, dynamic zones or relations.\n * This ensures all necessary draft's exist before copying it's relations.\n */\nasync function copyPublishedEntriesToDraft({\n  db,\n  trx,\n  uid,\n}: {\n  db: Database;\n  trx: Knex;\n  uid: string;\n}) {\n  // Extract all scalar attributes to use in the insert query\n  const meta = db.metadata.get(uid);\n\n  // Get scalar attributes that will be copied over the new draft\n  const scalarAttributes = Object.values(meta.attributes).reduce((acc, attribute: any) => {\n    if (['id'].includes(attribute.columnName)) {\n      return acc;\n    }\n\n    if (contentTypes.isScalarAttribute(attribute)) {\n      acc.push(attribute.columnName);\n    }\n\n    return acc;\n  }, [] as string[]);\n\n  /**\n   * Query to copy the published entries into draft entries.\n   *\n   * INSERT INTO tableName (columnName1, columnName2, columnName3, ...)\n   * SELECT columnName1, columnName2, columnName3, ...\n   * FROM tableName\n   */\n  await trx\n    // INSERT INTO tableName (columnName1, columnName2, columnName3, ...)\n    .into(\n      trx.raw(`?? (${scalarAttributes.map(() => `??`).join(', ')})`, [\n        meta.tableName,\n        ...scalarAttributes,\n      ])\n    )\n    .insert((subQb: typeof trx) => {\n      // SELECT columnName1, columnName2, columnName3, ...\n      subQb\n        .select(\n          ...scalarAttributes.map((att: string) => {\n            // NOTE: these literals reference Strapi's built-in system columns. They never get shortened by\n            // the identifier migration (5.0.0-01-convert-identifiers-long-than-max-length) so we can safely\n            // compare/use them directly here.\n            if (att === 'published_at') {\n              return trx.raw('NULL as ??', 'published_at');\n            }\n\n            return att;\n          })\n        )\n        .from(meta.tableName)\n        // Only select entries that were published\n        .whereNotNull('published_at');\n    });\n}\n\n/**\n * Orchestrates the relation cloning pipeline for a single content type. We duplicate\n * every category of relation (self, inbound, outbound, components) using direct SQL so\n * the migration can scale without calling `discardDraft` entry by entry.\n */\nasync function copyRelationsToDrafts({ db, trx, uid }: { db: Database; trx: Knex; uid: string }) {\n  const meta = db.metadata.get(uid);\n  if (!meta) {\n    return;\n  }\n\n  // Create mapping from published entry ID to draft entry ID\n  const publishedToDraftMap = await buildPublishedToDraftMap({ trx, uid, meta });\n\n  if (!publishedToDraftMap || publishedToDraftMap.size === 0) {\n    return;\n  }\n\n  // Copy relations for this content type\n  await copyRelationsForContentType({\n    trx,\n    uid,\n    publishedToDraftMap,\n  });\n\n  // Copy relations from other content types that target this content type\n  await copyRelationsFromOtherContentTypes({\n    trx,\n    uid,\n    publishedToDraftMap,\n  });\n\n  // Copy relations from this content type that target other content types (category 3)\n  await copyRelationsToOtherContentTypes({\n    trx,\n    uid,\n    publishedToDraftMap,\n  });\n\n  // Copy component relations from published entries to draft entries\n  await copyComponentRelations({\n    trx,\n    uid,\n    publishedToDraftMap,\n  });\n}\n\n/**\n * Splits large input arrays into smaller batches so we can run SQL queries without\n * hitting parameter limits (SQLite) or payload limits (MySQL/Postgres).\n */\nfunction chunkArray<T>(array: T[], chunkSize: number): T[][] {\n  const chunks: T[][] = [];\n  for (let i = 0; i < array.length; i += chunkSize) {\n    chunks.push(array.slice(i, i + chunkSize));\n  }\n  return chunks;\n}\n\n/**\n * Bulk-load existing relation rows for (sourceId, newTargetId) pairs so we can avoid\n * per-row SELECTs when deciding update vs delete.\n */\nasync function buildExistingRelationMap({\n  trx,\n  tableName,\n  sourceColumnName,\n  targetColumnName,\n  updates,\n  batchSize,\n}: {\n  trx: Knex;\n  tableName: string;\n  sourceColumnName: string;\n  targetColumnName: string;\n  updates: Array<{ sourceId: number; newTargetId: number }>;\n  batchSize: number;\n}): Promise<Map<string, number>> {\n  const existingMap = new Map<string, number>();\n  if (updates.length === 0) {\n    return existingMap;\n  }\n\n  const queryChunks = chunkArray(updates, batchSize);\n  for (const chunk of queryChunks) {\n    const rows = await trx(tableName)\n      .select(['id', sourceColumnName, targetColumnName])\n      .where((qb) => {\n        for (const update of chunk) {\n          qb.orWhere((subQb) => {\n            subQb\n              .where(sourceColumnName, update.sourceId)\n              .where(targetColumnName, update.newTargetId);\n          });\n        }\n      });\n\n    for (const row of rows) {\n      const key = `${row[sourceColumnName]}_${row[targetColumnName]}`;\n      existingMap.set(key, row.id);\n    }\n  }\n\n  return existingMap;\n}\n\n/**\n * Chooses a safe batch size for bulk operations depending on the database engine,\n * falling back to smaller units on engines (notably SQLite) that have low limits.\n */\nfunction getBatchSize(trx: Knex, defaultSize: number = 1000): number {\n  const client = trx.client.config.client;\n  const isSQLite =\n    typeof client === 'string' && ['sqlite', 'sqlite3', 'better-sqlite3'].includes(client);\n\n  // SQLite documentation states that the maximum number of terms in a\n  // compound SELECT statement is 500 by default.\n  // See: https://www.sqlite.org/limits.html\n  // We use 250 to be safe and account for other query complexity.\n  return isSQLite ? Math.min(defaultSize, 250) : defaultSize;\n}\n\n/**\n * Applies stable ordering to join-table queries so cloning work is deterministic and\n * matches the ordering logic used by the entity service (important for tests and DZ order).\n */\nconst applyJoinTableOrdering = (qb: any, joinTable: any, sourceColumnName: string) => {\n  const seenColumns = new Set<string>();\n\n  const enqueueColumn = (column?: string, direction: 'asc' | 'desc' = 'asc') => {\n    if (!column || seenColumns.has(column)) {\n      return;\n    }\n\n    seenColumns.add(column);\n    qb.orderBy(column, direction);\n  };\n\n  enqueueColumn(sourceColumnName, 'asc');\n\n  if (Array.isArray(joinTable?.orderBy)) {\n    for (const clause of joinTable.orderBy) {\n      if (!clause || typeof clause !== 'object') {\n        continue;\n      }\n\n      const [column, direction] = Object.entries(clause)[0] ?? [];\n      if (!column) {\n        continue;\n      }\n\n      const normalizedDirection =\n        typeof direction === 'string' && direction.toLowerCase() === 'desc' ? 'desc' : 'asc';\n      enqueueColumn(column, normalizedDirection as 'asc' | 'desc');\n    }\n  }\n\n  enqueueColumn(joinTable?.orderColumnName, 'asc');\n  enqueueColumn(joinTable?.orderColumn, 'asc');\n  enqueueColumn('id', 'asc');\n};\n\n/**\n * Builds a stable key for join-table relations to detect duplicates.\n * Key format: sourceId::targetId::field::componentType\n */\nconst buildRelationKey = (\n  relation: Record<string, any>,\n  sourceColumnName: string,\n  targetId: number | string | null\n): string => {\n  const sourceId = normalizeId(relation[sourceColumnName]) ?? relation[sourceColumnName];\n  const fieldValue = 'field' in relation ? (relation.field ?? '') : '';\n  const componentTypeValue = 'component_type' in relation ? (relation.component_type ?? '') : '';\n\n  return `${sourceId ?? 'null'}::${targetId ?? 'null'}::${fieldValue}::${componentTypeValue}`;\n};\n\n/**\n * Queries existing relations from a join table and builds a set of keys for duplicate detection.\n */\nasync function getExistingRelationKeys({\n  trx,\n  joinTable,\n  sourceColumnName,\n  targetColumnName,\n  sourceIds,\n}: {\n  trx: Knex;\n  joinTable: any;\n  sourceColumnName: string;\n  targetColumnName: string;\n  sourceIds: number[];\n}): Promise<Set<string>> {\n  const existingKeys = new Set<string>();\n\n  if (sourceIds.length === 0) {\n    return existingKeys;\n  }\n\n  const idChunks = chunkArray(sourceIds, getBatchSize(trx, 1000));\n  for (const chunk of idChunks) {\n    const existingRelationsQuery = trx(joinTable.name).select('*').whereIn(sourceColumnName, chunk);\n\n    applyJoinTableOrdering(existingRelationsQuery, joinTable, sourceColumnName);\n\n    const existingRelations = await existingRelationsQuery;\n\n    for (const relation of existingRelations) {\n      const targetId = normalizeId(relation[targetColumnName]) ?? relation[targetColumnName];\n      const key = buildRelationKey(relation, sourceColumnName, targetId);\n      existingKeys.add(key);\n    }\n  }\n\n  return existingKeys;\n}\n\n/**\n * Inserts relations into a join table with database-specific duplicate handling.\n * Tries batch insert first, then falls back to individual inserts with conflict handling.\n */\nasync function insertRelationsWithDuplicateHandling({\n  trx,\n  tableName,\n  relations,\n  context = {},\n}: {\n  trx: Knex;\n  tableName: string;\n  relations: Array<Record<string, any>>;\n  context?: Record<string, any>;\n}): Promise<void> {\n  if (relations.length === 0) {\n    return;\n  }\n\n  try {\n    await trx.batchInsert(tableName, relations, getBatchSize(trx, 1000));\n  } catch (error: any) {\n    // If batch insert fails due to duplicates, try with conflict handling\n    if (!isDuplicateEntryError(error)) {\n      throw error;\n    }\n\n    const client = trx.client.config.client;\n    if (client === 'postgres' || client === 'pg') {\n      for (const relation of relations) {\n        try {\n          await trx(tableName).insert(relation).onConflict().ignore();\n        } catch (err: any) {\n          if (err.code !== '23505' && !err.message?.includes('duplicate key')) {\n            throw err;\n          }\n        }\n      }\n    } else {\n      // MySQL and SQLite: use insertRowWithDuplicateHandling\n      for (const relation of relations) {\n        await insertRowWithDuplicateHandling(trx, tableName, relation, context);\n      }\n    }\n  }\n}\n\ntype ParentSchemaInfo = { uid: string; collectionName?: string };\ntype ComponentParentInstance = { uid: string; parentId: number | string };\n\nconst componentParentSchemasCache = new Map<string, ParentSchemaInfo[]>();\nconst joinTableExistsCache = new Map<string, boolean>();\nconst componentMetaCache = new Map<string, any>();\n\nconst SKIPPED_RELATION_SAMPLE_LIMIT = 5;\n\nconst supportsReturning = (trx: Knex) => {\n  const client = trx.client.config.client;\n  if (typeof client !== 'string') {\n    return false;\n  }\n\n  return ['postgres', 'pg'].includes(client.toLowerCase());\n};\n\ntype SkippedRelationContext = {\n  sourceUid: string;\n  attributeName: string;\n  targetUid?: string;\n  joinTable?: string;\n};\n\ntype SkippedRelationStatsEntry = SkippedRelationContext & {\n  count: number;\n  samples: Set<string>;\n};\n\nconst skippedRelationStats = new Map<string, SkippedRelationStatsEntry>();\n\nconst DUPLICATE_ERROR_CODES = new Set(['23505', 'ER_DUP_ENTRY', 'SQLITE_CONSTRAINT_UNIQUE']);\n\nconst debug = createDebug('strapi::migration::discard-drafts');\n\n/**\n * Converts arbitrary id values into numbers when possible so we can safely index into\n * mapping tables without worrying about string/number mismatches.\n */\nconst normalizeId = (value: any): number | null => {\n  if (value == null) {\n    return null;\n  }\n\n  const num = Number(value);\n\n  if (Number.isNaN(num)) {\n    return null;\n  }\n\n  return num;\n};\n\n/**\n * Wrapper around map lookups that first normalizes the provided identifier.\n */\nconst getMappedValue = <T>(map: Map<number, T> | null | undefined, key: any): T | undefined => {\n  if (!map) {\n    return undefined;\n  }\n\n  const normalized = normalizeId(key);\n\n  if (normalized == null) {\n    return undefined;\n  }\n\n  return map.get(normalized);\n};\n\n/**\n * Extracts the inserted row identifier across the various shapes returned by different\n * clients/drivers (numbers, objects, arrays). Falls back to `null` if nothing usable.\n */\nconst resolveInsertedId = (insertResult: any): number | null => {\n  if (insertResult == null) {\n    return null;\n  }\n\n  if (typeof insertResult === 'number') {\n    return insertResult;\n  }\n\n  if (Array.isArray(insertResult)) {\n    if (insertResult.length === 0) {\n      return null;\n    }\n\n    const first = insertResult[0];\n    if (first == null) {\n      return null;\n    }\n\n    if (typeof first === 'number') {\n      return first;\n    }\n\n    if (typeof first === 'object') {\n      if ('id' in first) {\n        return Number(first.id);\n      }\n\n      const idKey = Object.keys(first).find((key) => key.toLowerCase() === 'id');\n      if (idKey) {\n        return Number((first as Record<string, any>)[idKey]);\n      }\n    }\n  }\n\n  if (typeof insertResult === 'object' && 'id' in insertResult) {\n    return Number(insertResult.id);\n  }\n\n  return null;\n};\n\n/**\n * Detects vendor-specific duplicate key errors so we can safely ignore them when our\n * goal is to insert-or-ignore without branching on the client everywhere.\n */\nconst isDuplicateEntryError = (error: any): boolean => {\n  if (!error) {\n    return false;\n  }\n\n  if (DUPLICATE_ERROR_CODES.has(error.code)) {\n    return true;\n  }\n\n  const message = typeof error.message === 'string' ? error.message : '';\n  return message.includes('duplicate key') || message.includes('UNIQUE constraint failed');\n};\n\n/**\n * Inserts a row while tolerating duplicates across all supported clients. Used when\n * bulk operations fall back to single inserts to resolve constraint conflicts.\n */\nconst insertRowWithDuplicateHandling = async (\n  trx: Knex,\n  tableName: string,\n  row: Record<string, any>,\n  context: Record<string, any> = {}\n) => {\n  try {\n    const client = trx.client.config.client;\n\n    if (\n      client === 'postgres' ||\n      client === 'pg' ||\n      client === 'sqlite3' ||\n      client === 'better-sqlite3'\n    ) {\n      await trx(tableName).insert(row).onConflict().ignore();\n      return;\n    }\n\n    if (client === 'mysql' || client === 'mysql2') {\n      await trx.raw(`INSERT IGNORE INTO ?? SET ?`, [tableName, row]);\n      return;\n    }\n\n    await trx(tableName).insert(row);\n  } catch (error: any) {\n    if (!isDuplicateEntryError(error)) {\n      const details = JSON.stringify(context);\n      const wrapped = new Error(\n        `Failed to insert row into ${tableName}: ${error.message} | context=${details}`\n      );\n      (wrapped as any).cause = error;\n      throw wrapped;\n    }\n  }\n};\n\n/**\n * Normalizes identifiers into a comparable string so we can dedupe target ids\n * regardless of whether they come in as numbers, strings, or objects.\n */\nconst toComparisonKey = (value: any): string => {\n  if (value === null || value === undefined) {\n    return 'null';\n  }\n\n  if (typeof value === 'object') {\n    try {\n      return JSON.stringify(value);\n    } catch {\n      return String(value);\n    }\n  }\n\n  return String(value);\n};\n\n/**\n * Formats ids for log output while keeping the log lightweight and JSON-safe.\n */\nconst toDisplayValue = (value: any): string => {\n  if (value === null || value === undefined) {\n    return 'null';\n  }\n\n  if (typeof value === 'string' || typeof value === 'number' || typeof value === 'bigint') {\n    return String(value);\n  }\n\n  try {\n    return JSON.stringify(value);\n  } catch {\n    return String(value);\n  }\n};\n\n/**\n * Tracks how many relation rows we skipped because their targets are missing, so we\n * can emit a consolidated warning once the migration finishes copying relations.\n */\nfunction recordSkippedRelations(context: SkippedRelationContext, skippedIds: any[]) {\n  if (!skippedIds.length) {\n    return;\n  }\n\n  const key = `${context.sourceUid}::${context.attributeName}::${context.joinTable ?? 'NO_JOIN_TABLE'}`;\n  let stats = skippedRelationStats.get(key);\n\n  if (!stats) {\n    stats = {\n      ...context,\n      count: 0,\n      samples: new Set<string>(),\n    };\n  }\n\n  stats.count += skippedIds.length;\n\n  for (const id of skippedIds) {\n    if (stats.samples.size >= SKIPPED_RELATION_SAMPLE_LIMIT) {\n      break;\n    }\n\n    stats.samples.add(toDisplayValue(id));\n  }\n\n  skippedRelationStats.set(key, stats);\n}\n\n/**\n * Emits aggregated warnings for all skipped relations and resets the counters.\n * This keeps the log readable even when millions of orphaned rows exist.\n */\nfunction flushSkippedRelationLogs() {\n  if (skippedRelationStats.size === 0) {\n    return;\n  }\n\n  for (const stats of skippedRelationStats.values()) {\n    const sampleArray = Array.from(stats.samples);\n    const sampleText = sampleArray.length > 0 ? sampleArray.join(', ') : 'n/a';\n    const targetInfo = stats.targetUid ? `target=${stats.targetUid}` : 'target=unknown';\n    const joinTableInfo = stats.joinTable ? `joinTable=${stats.joinTable}` : 'joinTable=n/a';\n    const ellipsis = stats.count > sampleArray.length ? ', ...' : '';\n\n    strapi.log.warn(\n      `[discard-drafts] Skipped ${stats.count} relation(s) for ${stats.sourceUid}.${stats.attributeName} (${targetInfo}, ${joinTableInfo}). Example target ids: ${sampleText}${ellipsis}`\n    );\n  }\n\n  strapi.log.warn(\n    '[discard-drafts] Some join-table relations referenced missing targets and were skipped. Review these warnings and clean up orphaned relations before rerunning the migration if needed.'\n  );\n\n  skippedRelationStats.clear();\n}\n\n/**\n * Returns every schema (content type or component) that can embed the provided component.\n * Cached because we consult it repeatedly while remapping nested components.\n */\nfunction listComponentParentSchemas(componentUid: string): ParentSchemaInfo[] {\n  if (!componentParentSchemasCache.has(componentUid)) {\n    const schemas = [\n      ...Object.values(strapi.contentTypes),\n      ...Object.values(strapi.components),\n    ] as any[];\n\n    const parents = schemas\n      .filter((schema) => {\n        if (!schema?.attributes) {\n          return false;\n        }\n\n        return Object.values(schema.attributes).some((attr: any) => {\n          if (attr.type === 'component') {\n            return attr.component === componentUid;\n          }\n\n          if (attr.type === 'dynamiczone') {\n            return attr.components?.includes(componentUid);\n          }\n\n          return false;\n        });\n      })\n      .map((schema) => ({ uid: schema.uid, collectionName: schema.collectionName }));\n\n    componentParentSchemasCache.set(componentUid, parents);\n  }\n\n  return componentParentSchemasCache.get(componentUid)!;\n}\n\n/**\n * Memoized helper for checking whether a table exists. Avoids repeating expensive\n * information_schema queries when we touch the same join table many times.\n */\nasync function ensureTableExists(trx: Knex, tableName: string): Promise<boolean> {\n  if (!joinTableExistsCache.has(tableName)) {\n    const exists = await trx.schema.hasTable(tableName);\n    joinTableExistsCache.set(tableName, exists);\n  }\n\n  return joinTableExistsCache.get(tableName)!;\n}\n\ntype FilterRelationsWithExistingTargetsParams<T> = {\n  trx: Knex;\n  targetUid?: string;\n  relations: T[];\n  getTargetId: (relation: T) => any;\n};\n\n/**\n * Filters out relation rows whose target entity no longer exists, returning the safe\n * rows along with a list of skipped ids so we can log them later.\n */\nasync function filterRelationsWithExistingTargets<T>({\n  trx,\n  targetUid,\n  relations,\n  getTargetId,\n}: FilterRelationsWithExistingTargetsParams<T>): Promise<{ relations: T[]; skippedIds: any[] }> {\n  if (!relations.length) {\n    return { relations, skippedIds: [] };\n  }\n\n  if (!targetUid) {\n    return { relations, skippedIds: [] };\n  }\n\n  const targetMeta = strapi.db.metadata.get(targetUid);\n  if (!targetMeta) {\n    return { relations, skippedIds: [] };\n  }\n\n  const tableName = targetMeta.tableName;\n  const primaryKeyColumn = resolvePrimaryKeyColumn(targetMeta);\n\n  if (!tableName) {\n    return { relations, skippedIds: [] };\n  }\n\n  const uniqueIdMap = new Map<string, any>();\n\n  for (const relation of relations) {\n    const targetId = getTargetId(relation);\n\n    if (targetId == null) {\n      continue;\n    }\n\n    const key = toComparisonKey(targetId);\n    if (!uniqueIdMap.has(key)) {\n      uniqueIdMap.set(key, targetId);\n    }\n  }\n\n  if (uniqueIdMap.size === 0) {\n    return { relations, skippedIds: [] };\n  }\n\n  const hasTable = await ensureTableExists(trx, tableName);\n  if (!hasTable) {\n    return { relations: [], skippedIds: Array.from(uniqueIdMap.values()) };\n  }\n\n  const existingKeys = new Set<string>();\n  const uniqueIds = Array.from(uniqueIdMap.values());\n  const idChunks = chunkArray(uniqueIds, getBatchSize(trx, 1000));\n\n  for (const chunk of idChunks) {\n    const rows = await trx(tableName).select(primaryKeyColumn).whereIn(primaryKeyColumn, chunk);\n    for (const row of rows) {\n      const value = row[primaryKeyColumn];\n      existingKeys.add(toComparisonKey(value));\n    }\n  }\n\n  const filteredRelations: T[] = [];\n  const skippedIds: any[] = [];\n\n  for (const relation of relations) {\n    const targetId = getTargetId(relation);\n\n    if (targetId == null) {\n      skippedIds.push(targetId);\n      continue;\n    }\n\n    if (existingKeys.has(toComparisonKey(targetId))) {\n      filteredRelations.push(relation);\n    } else {\n      skippedIds.push(targetId);\n    }\n  }\n\n  return { relations: filteredRelations, skippedIds };\n}\n\ntype ComponentHierarchyCaches = {\n  parentInstanceCache: Map<string, ComponentParentInstance | null>;\n  ancestorDpCache: Map<string, boolean>;\n  parentDpCache: Map<string, boolean>;\n};\n\n/**\n * Locates the owning entity (content type or component) for a given component instance.\n * This mirrors the document service logic we need in order to decide whether a relation\n * should propagate to drafts, and is cached for performance.\n */\nasync function findComponentParentInstance(\n  trx: Knex,\n  identifiers: any,\n  componentUid: string,\n  componentId: number | string,\n  excludeUid: string | undefined,\n  caches: ComponentHierarchyCaches\n): Promise<ComponentParentInstance | null> {\n  const cacheKey = `${componentUid}:${componentId}:${excludeUid ?? 'ALL'}`;\n  if (caches.parentInstanceCache.has(cacheKey)) {\n    return caches.parentInstanceCache.get(cacheKey)!;\n  }\n\n  const parentComponentIdColumn = getComponentJoinColumnInverseName(identifiers);\n  const parentComponentTypeColumn = getComponentTypeColumn(identifiers);\n  const parentEntityIdColumn = getComponentJoinColumnEntityName(identifiers);\n\n  const potentialParents = listComponentParentSchemas(componentUid).filter(\n    (schema) => schema.uid !== excludeUid\n  );\n\n  for (const parentSchema of potentialParents) {\n    if (!parentSchema.collectionName) {\n      continue;\n    }\n\n    const parentJoinTableName = getComponentJoinTableName(parentSchema.collectionName, identifiers);\n\n    try {\n      if (!(await ensureTableExists(trx, parentJoinTableName))) {\n        continue;\n      }\n\n      const parentRow = await trx(parentJoinTableName)\n        .where({\n          [parentComponentIdColumn]: componentId,\n          [parentComponentTypeColumn]: componentUid,\n        })\n        .first(parentEntityIdColumn);\n\n      if (parentRow) {\n        const parentInstance: ComponentParentInstance = {\n          uid: parentSchema.uid,\n          parentId: parentRow[parentEntityIdColumn],\n        };\n\n        caches.parentInstanceCache.set(cacheKey, parentInstance);\n        return parentInstance;\n      }\n    } catch {\n      continue;\n    }\n  }\n\n  caches.parentInstanceCache.set(cacheKey, null);\n  return null;\n}\n\n/**\n * Fetches and caches database metadata for a component uid. Saves repeated lookups while\n * cloning the same component type thousands of times.\n */\nconst getComponentMeta = (componentUid: string) => {\n  if (!componentMetaCache.has(componentUid)) {\n    const meta = strapi.db.metadata.get(componentUid);\n    componentMetaCache.set(componentUid, meta ?? null);\n  }\n\n  return componentMetaCache.get(componentUid);\n};\n\n/**\n * Determines whether a component's parent entity participates in draft/publish,\n * short-circuiting a lot of recursion when deciding relation propagation rules.\n */\nasync function hasDraftPublishAncestorForParent(\n  trx: Knex,\n  identifiers: any,\n  parent: ComponentParentInstance,\n  caches: ComponentHierarchyCaches\n): Promise<boolean> {\n  const cacheKey = `${parent.uid}:${parent.parentId}`;\n  if (caches.parentDpCache.has(cacheKey)) {\n    return caches.parentDpCache.get(cacheKey)!;\n  }\n\n  const parentContentType = strapi.contentTypes[\n    parent.uid as keyof typeof strapi.contentTypes\n  ] as any;\n  if (parentContentType) {\n    const result = !!parentContentType?.options?.draftAndPublish;\n    caches.parentDpCache.set(cacheKey, result);\n    return result;\n  }\n\n  const parentComponent = strapi.components[parent.uid as keyof typeof strapi.components] as any;\n  if (!parentComponent) {\n    caches.parentDpCache.set(cacheKey, false);\n    return false;\n  }\n\n  const result = await hasDraftPublishAncestorForComponent(\n    trx,\n    identifiers,\n    parent.uid,\n    parent.parentId,\n    undefined,\n    caches\n  );\n  caches.parentDpCache.set(cacheKey, result);\n  return result;\n}\n\n/**\n * Recursively checks whether a component lies beneath a draft/publish-enabled parent\n * component or content type. We mirror discardDraft's propagation guard.\n */\nasync function hasDraftPublishAncestorForComponent(\n  trx: Knex,\n  identifiers: any,\n  componentUid: string,\n  componentId: number | string,\n  excludeUid: string | undefined,\n  caches: ComponentHierarchyCaches\n): Promise<boolean> {\n  const cacheKey = `${componentUid}:${componentId}:${excludeUid ?? 'ALL'}`;\n  if (caches.ancestorDpCache.has(cacheKey)) {\n    return caches.ancestorDpCache.get(cacheKey)!;\n  }\n\n  const parent = await findComponentParentInstance(\n    trx,\n    identifiers,\n    componentUid,\n    componentId,\n    excludeUid,\n    caches\n  );\n\n  if (!parent) {\n    caches.ancestorDpCache.set(cacheKey, false);\n    return false;\n  }\n\n  const result = await hasDraftPublishAncestorForParent(trx, identifiers, parent, caches);\n  caches.ancestorDpCache.set(cacheKey, result);\n  return result;\n}\n\n/**\n * Abstracts `NOW()` handling so that timestamps stay consistent across databases—\n * using Knex's native function when available and falling back to JS dates otherwise.\n */\nconst resolveNowValue = (trx: Knex) => {\n  if (typeof trx.fn?.now === 'function') {\n    return trx.fn.now();\n  }\n\n  return new Date();\n};\n\n/**\n * Builds or retrieves the published→draft id map for a target content type, caching\n * the result so nested relation remapping can reuse the work.\n */\nasync function getDraftMapForTarget(\n  trx: Knex,\n  targetUid: string,\n  draftMapCache: Map<string, Map<number, number> | null>\n): Promise<Map<number, number> | null> {\n  if (draftMapCache.has(targetUid)) {\n    return draftMapCache.get(targetUid) ?? null;\n  }\n\n  const targetMeta = strapi.db.metadata.get(targetUid);\n  if (!targetMeta) {\n    draftMapCache.set(targetUid, null);\n    return null;\n  }\n\n  const map = await buildPublishedToDraftMap({\n    trx,\n    uid: targetUid,\n    meta: targetMeta,\n    options: { requireDraftAndPublish: true },\n  });\n\n  draftMapCache.set(targetUid, map ?? null);\n  return map ?? null;\n}\n\n/**\n * Builds a reverse map from draft IDs to published IDs for a target content type.\n * This is needed to check if a target ID is already a draft and find its published version.\n */\nasync function getDraftToPublishedMap(\n  trx: Knex,\n  targetUid: string,\n  reverseMapCache: Map<string, Map<number, number> | null>\n): Promise<Map<number, number> | null> {\n  if (reverseMapCache.has(targetUid)) {\n    return reverseMapCache.get(targetUid) ?? null;\n  }\n\n  const targetMeta = strapi.db.metadata.get(targetUid);\n  if (!targetMeta) {\n    reverseMapCache.set(targetUid, null);\n    return null;\n  }\n\n  const draftToPublishedMap = new Map<number, number>();\n  const draftMap = await getDraftMapForTarget(trx, targetUid, new Map());\n  if (draftMap) {\n    // Reverse the published->draft map to get draft->published\n    for (const [publishedId, draftId] of draftMap.entries()) {\n      draftToPublishedMap.set(draftId, publishedId);\n    }\n    debug(\n      `[getDraftToPublishedMap] ${targetUid}: Built reverse map with ${draftToPublishedMap.size} entries (draft->published)`\n    );\n  } else {\n    debug(`[getDraftToPublishedMap] ${targetUid}: No draft map found, returning null`);\n  }\n\n  reverseMapCache.set(targetUid, draftToPublishedMap.size > 0 ? draftToPublishedMap : null);\n  return draftToPublishedMap.size > 0 ? draftToPublishedMap : null;\n}\n\n/**\n * Checks if a target ID is published or draft by querying the database.\n */\nasync function getTargetPublicationState(\n  trx: Knex,\n  targetId: number | string,\n  targetUid: string\n): Promise<'published' | 'draft' | null> {\n  const targetMeta = strapi.db.metadata.get(targetUid);\n  if (!targetMeta) {\n    return null;\n  }\n\n  const target = await trx(targetMeta.tableName)\n    .select('published_at')\n    .where('id', targetId)\n    .first();\n\n  if (!target) {\n    return null;\n  }\n\n  return target.published_at !== null ? 'published' : 'draft';\n}\n\n/**\n * Maps relation foreign keys so that draft entities reference draft targets when those\n * targets exist; otherwise we preserve the original reference (matching discardDraft).\n *\n * When mapping for a draft component: maps published targets → draft targets\n * When mapping for a published component: maps draft targets → published targets (if needed)\n */\nasync function mapTargetId(\n  trx: Knex,\n  originalId: number | string | null,\n  targetUid: string | undefined,\n  parentUid: string,\n  parentPublishedToDraftMap: Map<number, number>,\n  draftMapCache: Map<string, Map<number, number> | null>,\n  isForDraftEntity: boolean = true,\n  reverseMapCache?: Map<string, Map<number, number> | null>\n) {\n  if (originalId == null || !targetUid) {\n    return originalId;\n  }\n\n  if (targetUid === parentUid) {\n    if (isForDraftEntity) {\n      return parentPublishedToDraftMap.get(Number(originalId)) ?? originalId;\n    }\n    // For published entity, if we got a draft ID, find the published version\n    const effectiveReverseCache = reverseMapCache ?? new Map();\n    const reverseMap = await getDraftToPublishedMap(trx, targetUid, effectiveReverseCache);\n    if (reverseMap) {\n      return reverseMap.get(Number(originalId)) ?? originalId;\n    }\n    return originalId;\n  }\n\n  const targetMap = await getDraftMapForTarget(trx, targetUid, draftMapCache);\n  if (!targetMap) {\n    return originalId;\n  }\n\n  // Check if the original ID is already a draft or published\n  const targetState = await getTargetPublicationState(trx, Number(originalId), targetUid);\n\n  if (isForDraftEntity) {\n    // For draft entities: map published targets to draft targets\n    if (targetState === 'published') {\n      return targetMap.get(Number(originalId)) ?? originalId;\n    }\n    if (targetState === 'draft') {\n      // Already a draft, keep it\n      return originalId;\n    }\n    // If we can't determine state, try the map lookup\n    return targetMap.get(Number(originalId)) ?? originalId;\n  }\n  // For published entities: map draft targets to published targets\n  if (targetState === 'draft') {\n    const effectiveReverseCache = reverseMapCache ?? new Map();\n    const reverseMap = await getDraftToPublishedMap(trx, targetUid, effectiveReverseCache);\n    if (reverseMap) {\n      return reverseMap.get(Number(originalId)) ?? originalId;\n    }\n    return originalId;\n  }\n  if (targetState === 'published') {\n    // Already published, keep it\n    return originalId;\n  }\n  // If we can't determine state, assume it's published\n  return originalId;\n}\n\n/**\n * Clones a database row and strips the `id` column so it can be reinserted as a new row.\n */\nconst ensureObjectWithoutId = (row: Record<string, any>) => {\n  const cloned = { ...row };\n  if ('id' in cloned) {\n    delete cloned.id;\n  }\n  return cloned;\n};\n\n/**\n * Duplicates join-table relations for a component instance while remapping any foreign\n * keys to draft targets. Mirrors the runtime clone logic but operates entirely in SQL.\n */\nasync function cloneComponentRelationJoinTables(\n  trx: Knex,\n  componentMeta: any,\n  componentUid: string,\n  originalComponentId: number,\n  newComponentId: number,\n  parentUid: string,\n  parentPublishedToDraftMap: Map<number, number>,\n  draftMapCache: Map<string, Map<number, number> | null>,\n  isForDraftEntity: boolean = true,\n  reverseMapCache?: Map<string, Map<number, number> | null>\n) {\n  for (const [attributeName, attribute] of Object.entries(componentMeta.attributes) as Array<\n    [string, any]\n  >) {\n    if (attribute.type !== 'relation' || !attribute.joinTable) {\n      continue;\n    }\n\n    const joinTable = attribute.joinTable;\n    const sourceColumnName = joinTable.joinColumn.name;\n    const targetColumnName = joinTable.inverseJoinColumn.name;\n\n    if (!componentMeta.relationsLogPrinted) {\n      debug(\n        `[cloneComponentRelationJoinTables] Inspecting join table ${joinTable.name} for component ${componentUid}`\n      );\n      componentMeta.relationsLogPrinted = true;\n    }\n\n    const relations = await trx(joinTable.name)\n      .select('*')\n      .where(sourceColumnName, originalComponentId);\n\n    if (relations.length === 0) {\n      continue;\n    }\n\n    const preparedRelations: Array<Record<string, any>> = [];\n\n    for (const relation of relations) {\n      const clonedRelation = ensureObjectWithoutId(relation);\n      clonedRelation[sourceColumnName] = newComponentId;\n\n      if (targetColumnName in clonedRelation) {\n        const originalTargetId = clonedRelation[targetColumnName];\n        clonedRelation[targetColumnName] = await mapTargetId(\n          trx,\n          clonedRelation[targetColumnName],\n          attribute.target,\n          parentUid,\n          parentPublishedToDraftMap,\n          draftMapCache,\n          isForDraftEntity,\n          reverseMapCache\n        );\n\n        debug(\n          `[cloneComponentRelationJoinTables] ${componentUid} join ${joinTable.name}: mapped ${targetColumnName} from ${originalTargetId} to ${clonedRelation[targetColumnName]} (target=${attribute.target})`\n        );\n      }\n\n      preparedRelations.push(clonedRelation);\n    }\n\n    let relationsToInsert = preparedRelations;\n\n    if (preparedRelations.some((relation) => targetColumnName in relation)) {\n      const { relations: safeRelations, skippedIds } = await filterRelationsWithExistingTargets({\n        trx,\n        targetUid: attribute.target,\n        relations: preparedRelations,\n        getTargetId: (relation) => relation[targetColumnName],\n      });\n\n      recordSkippedRelations(\n        {\n          sourceUid: componentUid,\n          attributeName,\n          targetUid: attribute.target,\n          joinTable: joinTable.name,\n        },\n        skippedIds\n      );\n\n      relationsToInsert = safeRelations;\n    }\n\n    if (relationsToInsert.length === 0) {\n      continue;\n    }\n\n    for (const relation of relationsToInsert) {\n      // Ensure we're only creating relations for the NEW component, not the original\n      // The sourceColumnName must be newComponentId to ensure we don't accidentally modify\n      // the original published component's relations\n      if (relation[sourceColumnName] !== newComponentId) {\n        debug(\n          `[cloneComponentRelationJoinTables] ERROR: Relation source ${relation[sourceColumnName]} does not match newComponentId ${newComponentId} - skipping to prevent modifying original component relations`\n        );\n        continue;\n      }\n\n      debug(\n        `[cloneComponentRelationJoinTables] inserting relation into ${joinTable.name} (component=${componentUid}, source=${relation[sourceColumnName]}, target=${relation[targetColumnName]})`\n      );\n\n      await insertRowWithDuplicateHandling(trx, joinTable.name, relation, {\n        componentUid,\n        originalComponentId,\n        newComponentId,\n        joinTable: joinTable.name,\n        sourceColumnName,\n        targetColumnName,\n        targetUid: attribute.target,\n        parentUid,\n      });\n    }\n  }\n}\n\n/**\n * Clones a component row (including nested relations) so the newly created draft entity\n * owns its own copy, matching what the document service would have produced.\n */\nasync function cloneComponentInstance({\n  trx,\n  componentUid,\n  componentId,\n  parentUid,\n  parentPublishedToDraftMap,\n  draftMapCache,\n  isForDraftEntity = true,\n  reverseMapCache,\n}: {\n  trx: Knex;\n  componentUid: string;\n  componentId: number;\n  parentUid: string;\n  parentPublishedToDraftMap: Map<number, number>;\n  draftMapCache: Map<string, Map<number, number> | null>;\n  isForDraftEntity?: boolean;\n  reverseMapCache?: Map<string, Map<number, number> | null>;\n}): Promise<number> {\n  const componentMeta = getComponentMeta(componentUid);\n  if (!componentMeta) {\n    return componentId;\n  }\n\n  const componentTableName = componentMeta.tableName;\n  const componentPrimaryKey = Number.isNaN(Number(componentId)) ? componentId : Number(componentId);\n  const componentRow = await trx(componentTableName)\n    .select('*')\n    .where('id', componentPrimaryKey)\n    .first();\n\n  if (!componentRow) {\n    return componentId;\n  }\n\n  const newComponentRow: Record<string, any> = ensureObjectWithoutId(componentRow);\n\n  // `document_id`, `created_at`, `updated_at` are Strapi system columns whose names remain stable across the\n  // identifier-shortening migration, so it’s safe to check them directly here.\n  if ('document_id' in newComponentRow) {\n    newComponentRow.document_id = createId();\n  }\n\n  if ('updated_at' in newComponentRow) {\n    newComponentRow.updated_at = resolveNowValue(trx);\n  }\n\n  if ('created_at' in newComponentRow && newComponentRow.created_at == null) {\n    newComponentRow.created_at = resolveNowValue(trx);\n  }\n\n  for (const attribute of Object.values(componentMeta.attributes) as any) {\n    if (attribute.type !== 'relation') {\n      continue;\n    }\n\n    const joinColumn = attribute.joinColumn;\n    if (!joinColumn) {\n      continue;\n    }\n\n    const columnName = joinColumn.name;\n    if (!columnName || !(columnName in newComponentRow)) {\n      continue;\n    }\n\n    newComponentRow[columnName] = await mapTargetId(\n      trx,\n      newComponentRow[columnName],\n      attribute.target,\n      parentUid,\n      parentPublishedToDraftMap,\n      draftMapCache,\n      isForDraftEntity,\n      reverseMapCache\n    );\n  }\n\n  let insertResult;\n  if (supportsReturning(trx)) {\n    try {\n      insertResult = await trx(componentTableName).insert(newComponentRow, ['id']);\n    } catch (error: any) {\n      insertResult = await trx(componentTableName).insert(newComponentRow);\n    }\n  } else {\n    insertResult = await trx(componentTableName).insert(newComponentRow);\n  }\n\n  let newComponentId = resolveInsertedId(insertResult);\n\n  if (!newComponentId) {\n    if ('document_id' in newComponentRow && newComponentRow.document_id) {\n      const insertedRow = await trx(componentTableName)\n        .select('id')\n        .where('document_id', newComponentRow.document_id)\n        .orderBy('id', 'desc')\n        .first();\n      newComponentId = insertedRow?.id ?? null;\n    }\n\n    if (!newComponentId) {\n      const insertedRow = await trx(componentTableName).select('id').orderBy('id', 'desc').first();\n      newComponentId = insertedRow?.id ?? null;\n    }\n  }\n\n  if (!newComponentId) {\n    throw new Error(`Failed to clone component ${componentUid} (id: ${componentId})`);\n  }\n\n  newComponentId = Number(newComponentId);\n\n  if (Number.isNaN(newComponentId)) {\n    throw new Error(`Invalid cloned component identifier for ${componentUid} (id: ${componentId})`);\n  }\n\n  await cloneComponentRelationJoinTables(\n    trx,\n    componentMeta,\n    componentUid,\n    Number(componentPrimaryKey),\n    newComponentId,\n    parentUid,\n    parentPublishedToDraftMap,\n    draftMapCache,\n    isForDraftEntity,\n    reverseMapCache\n  );\n\n  return newComponentId;\n}\n\ntype DraftMapOptions = {\n  requireDraftAndPublish?: boolean;\n};\n\n/**\n * Generates a map between published row ids and their corresponding draft ids so we can\n * rewire relations in bulk. Handles localization nuances and caches the newest draft.\n */\nasync function buildPublishedToDraftMap({\n  trx,\n  uid,\n  meta,\n  options = {},\n}: {\n  trx: Knex;\n  uid: string;\n  meta: any;\n  options?: DraftMapOptions;\n}): Promise<Map<number, number> | null> {\n  if (!meta) {\n    return null;\n  }\n\n  const model = strapi.getModel(uid as UID.ContentType);\n  const hasDraftAndPublishEnabled = contentTypes.hasDraftAndPublish(model);\n\n  if (options.requireDraftAndPublish && !hasDraftAndPublishEnabled) {\n    return null;\n  }\n\n  const [publishedEntries, draftEntries] = await Promise.all([\n    // `document_id`, `locale`, and `published_at` are core columns that keep their exact names after the\n    // identifier-shortening migration, so selecting them by literal is safe.\n    trx(meta.tableName).select(['id', 'document_id', 'locale']).whereNotNull('published_at') as any,\n    trx(meta.tableName).select(['id', 'document_id', 'locale']).whereNull('published_at') as any,\n  ]);\n\n  if (publishedEntries.length === 0 || draftEntries.length === 0) {\n    return null;\n  }\n\n  const i18nService = strapi.plugin('i18n')?.service('content-types');\n  const contentType = strapi.contentTypes[uid as keyof typeof strapi.contentTypes] as any;\n  const isLocalized = i18nService?.isLocalizedContentType(contentType) ?? false;\n\n  const draftByDocumentId = new Map<string, (typeof draftEntries)[0]>();\n  for (const draft of draftEntries) {\n    if (!draft.document_id) {\n      continue;\n    }\n\n    const key = isLocalized ? `${draft.document_id}:${draft.locale || ''}` : draft.document_id;\n    const existing = draftByDocumentId.get(key);\n    if (!existing) {\n      draftByDocumentId.set(key, draft);\n      continue;\n    }\n\n    const existingId = Number(existing.id);\n    const draftId = Number(draft.id);\n\n    if (Number.isNaN(existingId) || Number.isNaN(draftId)) {\n      draftByDocumentId.set(key, draft);\n      continue;\n    }\n\n    if (draftId > existingId) {\n      draftByDocumentId.set(key, draft);\n    }\n  }\n\n  const publishedToDraftMap = new Map<number, number>();\n  for (const published of publishedEntries) {\n    if (!published.document_id) {\n      continue;\n    }\n\n    const key = isLocalized\n      ? `${published.document_id}:${published.locale || ''}`\n      : published.document_id;\n\n    const draft = draftByDocumentId.get(key);\n    if (draft) {\n      const publishedId = normalizeId(published.id);\n      const draftId = normalizeId(draft.id);\n\n      if (publishedId == null || draftId == null) {\n        continue;\n      }\n\n      publishedToDraftMap.set(publishedId, draftId);\n    }\n  }\n\n  return publishedToDraftMap.size > 0 ? publishedToDraftMap : null;\n}\n\n/**\n * Copy relations within the same content type (self-referential relations)\n */\nasync function copyRelationsForContentType({\n  trx,\n  uid,\n  publishedToDraftMap,\n}: {\n  trx: Knex;\n  uid: string;\n  publishedToDraftMap: Map<number, number>;\n}) {\n  const meta = strapi.db.metadata.get(uid);\n  if (!meta) return;\n\n  const publishedIds = Array.from(publishedToDraftMap.keys());\n\n  for (const attribute of Object.values(meta.attributes) as any) {\n    if (attribute.type !== 'relation' || attribute.target !== uid) {\n      continue;\n    }\n\n    const joinTable = attribute.joinTable;\n    if (!joinTable) {\n      continue;\n    }\n\n    // Skip component join tables - they are handled by copyComponentRelations\n    if (joinTable.name.includes('_cmps')) {\n      continue;\n    }\n\n    const { name: sourceColumnName } = joinTable.joinColumn;\n    const { name: targetColumnName } = joinTable.inverseJoinColumn;\n\n    // Process in batches to avoid MySQL query size limits and SQLite expression tree limits\n    const publishedIdsChunks = chunkArray(publishedIds, getBatchSize(trx, 1000));\n\n    for (const publishedIdsChunk of publishedIdsChunks) {\n      const draftSourceIds = publishedIdsChunk\n        .map((value) => getMappedValue(publishedToDraftMap, value))\n        .filter((value): value is number => value != null) as number[];\n\n      // Get relations where the source is a published entry (in batches)\n      const relationsQuery = trx(joinTable.name)\n        .select('*')\n        .whereIn(sourceColumnName, publishedIdsChunk);\n\n      applyJoinTableOrdering(relationsQuery, joinTable, sourceColumnName);\n\n      const relations = await relationsQuery;\n\n      if (relations.length === 0) {\n        continue;\n      }\n\n      // Create new relations pointing to draft entries\n      // Remove the 'id' field to avoid duplicate key errors\n      const newRelations = relations\n        .map((relation) => {\n          const newSourceId = getMappedValue(publishedToDraftMap, relation[sourceColumnName]);\n          const newTargetId = getMappedValue(publishedToDraftMap, relation[targetColumnName]);\n\n          if (!newSourceId || !newTargetId) {\n            // Skip if no mapping found\n            return null;\n          }\n\n          // Create new relation object without the 'id' field\n          const { id, ...relationWithoutId } = relation;\n          return {\n            ...relationWithoutId,\n            [sourceColumnName]: newSourceId,\n            [targetColumnName]: newTargetId,\n          };\n        })\n        .filter(Boolean);\n\n      if (newRelations.length === 0) {\n        continue;\n      }\n\n      const existingKeys = await getExistingRelationKeys({\n        trx,\n        joinTable,\n        sourceColumnName,\n        targetColumnName,\n        sourceIds: draftSourceIds,\n      });\n\n      const relationsToInsert = newRelations.filter((relation) => {\n        const targetId = normalizeId(relation[targetColumnName]) ?? relation[targetColumnName];\n        const key = buildRelationKey(relation, sourceColumnName, targetId);\n        return !existingKeys.has(key);\n      });\n\n      if (relationsToInsert.length === 0) {\n        continue;\n      }\n\n      await insertRelationsWithDuplicateHandling({\n        trx,\n        tableName: joinTable.name,\n        relations: relationsToInsert,\n        context: {\n          reason: 'duplicate-self-relation-check',\n          sourceUid: uid,\n          targetUid: uid,\n        },\n      });\n    }\n  }\n}\n\n/**\n * Copy relations from other content types that target this content type\n */\nasync function copyRelationsFromOtherContentTypes({\n  trx,\n  uid,\n  publishedToDraftMap,\n}: {\n  trx: Knex;\n  uid: string;\n  publishedToDraftMap: Map<number, number>;\n}) {\n  const targetMeta = strapi.db.metadata.get(uid);\n  if (!targetMeta) {\n    return;\n  }\n\n  const publishedTargetIds = Array.from(publishedToDraftMap.keys())\n    .map((value) => normalizeId(value))\n    .filter((value): value is number => value != null);\n\n  if (publishedTargetIds.length === 0) {\n    return;\n  }\n\n  const draftTargetIds = Array.from(publishedToDraftMap.values())\n    .map((value) => normalizeId(value))\n    .filter((value): value is number => value != null);\n\n  const models = [\n    ...(Object.values(strapi.contentTypes) as any[]),\n    ...(Object.values(strapi.components) as any[]),\n  ];\n\n  for (const model of models) {\n    const dbModel = strapi.db.metadata.get(model.uid);\n    if (!dbModel) {\n      continue;\n    }\n\n    const sourceHasDraftAndPublish = Boolean(model.options?.draftAndPublish);\n\n    for (const attribute of Object.values(dbModel.attributes) as any) {\n      if (attribute.type !== 'relation' || attribute.target !== uid) {\n        continue;\n      }\n\n      const joinTable = attribute.joinTable;\n      if (!joinTable) {\n        continue;\n      }\n\n      // Component join tables are handled separately when cloning components.\n      if (joinTable.name.includes('_cmps')) {\n        continue;\n      }\n\n      // If the source content type also has draft/publish, its own cloning routine will recreate its relations.\n      if (sourceHasDraftAndPublish) {\n        continue;\n      }\n\n      const { name: sourceColumnName } = joinTable.joinColumn;\n      const { name: targetColumnName } = joinTable.inverseJoinColumn;\n\n      // Query existing relations by target IDs to avoid duplicates\n      const existingKeys = await getExistingRelationKeys({\n        trx,\n        joinTable,\n        sourceColumnName,\n        targetColumnName,\n        sourceIds: draftTargetIds,\n      });\n\n      const publishedIdChunks = chunkArray(publishedTargetIds, getBatchSize(trx, 1000));\n\n      for (const chunk of publishedIdChunks) {\n        const relationsQuery = trx(joinTable.name).select('*').whereIn(targetColumnName, chunk);\n\n        applyJoinTableOrdering(relationsQuery, joinTable, sourceColumnName);\n\n        const relations = await relationsQuery;\n        if (relations.length === 0) {\n          continue;\n        }\n\n        const newRelations: Array<Record<string, any>> = [];\n\n        for (const relation of relations) {\n          const newTargetId = getMappedValue(publishedToDraftMap, relation[targetColumnName]);\n          if (!newTargetId) {\n            continue;\n          }\n\n          const key = buildRelationKey(relation, sourceColumnName, newTargetId);\n          if (existingKeys.has(key)) {\n            continue;\n          }\n\n          existingKeys.add(key);\n\n          const { id, ...relationWithoutId } = relation;\n          newRelations.push({\n            ...relationWithoutId,\n            [targetColumnName]: newTargetId,\n          });\n        }\n\n        if (newRelations.length === 0) {\n          continue;\n        }\n\n        await insertRelationsWithDuplicateHandling({\n          trx,\n          tableName: joinTable.name,\n          relations: newRelations,\n          context: {\n            reason: 'duplicate-draft-target-relation',\n            sourceUid: model.uid,\n            targetUid: uid,\n          },\n        });\n      }\n    }\n  }\n}\n\n/**\n * Copy relations from this content type that target other content types (category 3)\n * Example: Article -> Categories/Tags\n */\nasync function copyRelationsToOtherContentTypes({\n  trx,\n  uid,\n  publishedToDraftMap,\n}: {\n  trx: Knex;\n  uid: string;\n  publishedToDraftMap: Map<number, number>;\n}) {\n  const meta = strapi.db.metadata.get(uid);\n  if (!meta) return;\n\n  const publishedIds = Array.from(publishedToDraftMap.keys());\n\n  // Cache target publishedToDraftMap to avoid duplicate calls for same target\n  const targetMapCache = new Map<string, Map<number, number> | null>();\n\n  for (const [attributeName, attribute] of Object.entries(meta.attributes) as Array<\n    [string, any]\n  >) {\n    if (attribute.type !== 'relation' || attribute.target === uid) {\n      // Skip self-referential relations (handled by copyRelationsForContentType)\n      continue;\n    }\n\n    const joinTable = attribute.joinTable;\n    if (!joinTable) {\n      continue;\n    }\n\n    // Skip component join tables - they are handled by copyComponentRelations\n    if (joinTable.name.includes('_cmps')) {\n      continue;\n    }\n\n    const { name: sourceColumnName } = joinTable.joinColumn;\n    const { name: targetColumnName } = joinTable.inverseJoinColumn;\n\n    // Get target content type's publishedToDraftMap if it has draft/publish (cached)\n    const targetUid = attribute.target;\n    if (!targetMapCache.has(targetUid)) {\n      const targetMeta = strapi.db.metadata.get(targetUid);\n      const targetMap = await buildPublishedToDraftMap({\n        trx,\n        uid: targetUid,\n        meta: targetMeta,\n        options: { requireDraftAndPublish: true },\n      });\n      targetMapCache.set(targetUid, targetMap);\n    }\n    const targetPublishedToDraftMap = targetMapCache.get(targetUid);\n\n    // Process in batches to avoid MySQL query size limits and SQLite expression tree limits\n    const publishedIdsChunks = chunkArray(publishedIds, getBatchSize(trx, 1000));\n\n    for (const publishedIdsChunk of publishedIdsChunks) {\n      // Get relations where the source is a published entry of our content type (in batches)\n      const relationsQuery = trx(joinTable.name)\n        .select('*')\n        .whereIn(sourceColumnName, publishedIdsChunk);\n\n      applyJoinTableOrdering(relationsQuery, joinTable, sourceColumnName);\n\n      const relations = await relationsQuery;\n\n      if (relations.length === 0) {\n        continue;\n      }\n\n      // Create new relations pointing to draft entries\n      // Remove the 'id' field to avoid duplicate key errors\n      const newRelations = relations\n        .map((relation) => {\n          const newSourceId = getMappedValue(publishedToDraftMap, relation[sourceColumnName]);\n\n          if (!newSourceId) {\n            return null;\n          }\n\n          // Map target ID to draft if target has draft/publish enabled\n          // This matches discard() behavior: drafts relate to drafts\n          let newTargetId = relation[targetColumnName];\n          if (targetPublishedToDraftMap) {\n            const mappedTargetId = getMappedValue(\n              targetPublishedToDraftMap,\n              relation[targetColumnName]\n            );\n            if (mappedTargetId !== undefined) {\n              newTargetId = mappedTargetId;\n            }\n            // If no draft mapping, keep published target (target might not have DP or was deleted)\n            // This will be fixed by fixExistingDraftRelations if needed\n          }\n\n          // Create new relation object without the 'id' field\n          const { id, ...relationWithoutId } = relation;\n          return {\n            ...relationWithoutId,\n            [sourceColumnName]: newSourceId,\n            [targetColumnName]: newTargetId,\n          };\n        })\n        .filter(Boolean);\n\n      const { relations: safeRelations, skippedIds } = await filterRelationsWithExistingTargets({\n        trx,\n        targetUid,\n        relations: newRelations as Array<Record<string, any>>,\n        getTargetId: (relation) => relation[targetColumnName],\n      });\n\n      recordSkippedRelations(\n        {\n          sourceUid: uid,\n          attributeName,\n          targetUid,\n          joinTable: joinTable.name,\n        },\n        skippedIds\n      );\n\n      if (safeRelations.length === 0) {\n        continue;\n      }\n\n      // Check for existing relations to avoid duplicates (similar to copyRelationsFromOtherContentTypes)\n      // This is important when the target doesn't have D&P, as copyRelationsFromOtherContentTypes\n      // may have already created some relations\n      const draftSourceIds = Array.from(publishedToDraftMap.values())\n        .map((value) => normalizeId(value))\n        .filter((value): value is number => value != null);\n\n      const existingKeys = await getExistingRelationKeys({\n        trx,\n        joinTable,\n        sourceColumnName,\n        targetColumnName,\n        sourceIds: draftSourceIds,\n      });\n\n      // Filter out relations that already exist\n      const relationsToInsert = safeRelations.filter((relation) => {\n        const targetId = normalizeId(relation[targetColumnName]) ?? relation[targetColumnName];\n        const key = buildRelationKey(relation, sourceColumnName, targetId);\n        return !existingKeys.has(key);\n      });\n\n      if (relationsToInsert.length > 0) {\n        await insertRelationsWithDuplicateHandling({\n          trx,\n          tableName: joinTable.name,\n          relations: relationsToInsert,\n          context: {\n            reason: 'duplicate-relation-check',\n            sourceUid: uid,\n            targetUid,\n          },\n        });\n      }\n    }\n  }\n}\n\n/**\n * Update JoinColumn relations (oneToOne, manyToOne foreign keys) to point to draft versions\n * This matches discard() behavior: when creating drafts, foreign keys should point to draft targets\n */\nasync function updateJoinColumnRelations({\n  db,\n  trx,\n  uid,\n}: {\n  db: Database;\n  trx: Knex;\n  uid: string;\n}) {\n  const meta = db.metadata.get(uid);\n  if (!meta) {\n    return;\n  }\n\n  // Create mapping from published entry ID to draft entry ID\n  const publishedToDraftMap = await buildPublishedToDraftMap({ trx, uid, meta });\n\n  if (!publishedToDraftMap || publishedToDraftMap.size === 0) {\n    return;\n  }\n\n  // Cache target publishedToDraftMap to avoid duplicate calls for same target\n  const targetMapCache = new Map<string, Map<number, number> | null>();\n\n  // Find all JoinColumn relations (oneToOne, manyToOne without joinTable)\n  for (const attribute of Object.values(meta.attributes) as any) {\n    if (attribute.type !== 'relation') {\n      continue;\n    }\n\n    // Skip relations with joinTable (handled by copyRelationsToOtherContentTypes)\n    if (attribute.joinTable) {\n      continue;\n    }\n\n    // Only handle oneToOne and manyToOne relations that use joinColumn\n    const joinColumn = attribute.joinColumn;\n    if (!joinColumn) {\n      continue;\n    }\n\n    const targetUid = attribute.target;\n    const foreignKeyColumn = joinColumn.name;\n\n    // Get target content type's publishedToDraftMap if it has draft/publish (cached)\n    if (!targetMapCache.has(targetUid)) {\n      const targetMeta = strapi.db.metadata.get(targetUid);\n      const targetMap = await buildPublishedToDraftMap({\n        trx,\n        uid: targetUid,\n        meta: targetMeta,\n        options: { requireDraftAndPublish: true },\n      });\n      targetMapCache.set(targetUid, targetMap);\n    }\n    const targetPublishedToDraftMap = targetMapCache.get(targetUid);\n\n    if (!targetPublishedToDraftMap) {\n      // Target doesn't have draft/publish, foreign keys are fine as-is\n      continue;\n    }\n\n    const draftIds = Array.from(publishedToDraftMap.values());\n    if (draftIds.length === 0) {\n      continue;\n    }\n\n    const draftIdsChunks = chunkArray(draftIds, getBatchSize(trx, 1000));\n\n    for (const draftIdsChunk of draftIdsChunks) {\n      // Get draft entries with their foreign key values\n      const draftEntriesWithFk = await trx(meta.tableName)\n        .select(['id', foreignKeyColumn])\n        .whereIn('id', draftIdsChunk)\n        .whereNotNull(foreignKeyColumn);\n\n      const updates = draftEntriesWithFk.reduce<\n        Array<{ id: number | string; draftTargetId: number | string }>\n      >((acc, draftEntry) => {\n        const publishedTargetIdRaw = draftEntry[foreignKeyColumn];\n        const normalizedPublishedTargetId = normalizeId(publishedTargetIdRaw);\n        const draftTargetId =\n          normalizedPublishedTargetId == null\n            ? undefined\n            : targetPublishedToDraftMap.get(normalizedPublishedTargetId);\n\n        if (draftTargetId != null && normalizeId(draftTargetId) !== normalizedPublishedTargetId) {\n          acc.push({ id: draftEntry.id as number | string, draftTargetId });\n        }\n\n        return acc;\n      }, []);\n\n      if (updates.length === 0) {\n        continue;\n      }\n\n      const caseFragments = updates.map(() => 'WHEN ? THEN ?').join(' ');\n      const idsPlaceholders = updates.map(() => '?').join(', ');\n\n      await trx.raw(\n        `UPDATE ?? SET ?? = CASE ?? ${caseFragments} ELSE ?? END WHERE ?? IN (${idsPlaceholders})`,\n        [\n          meta.tableName,\n          foreignKeyColumn,\n          'id',\n          ...updates.flatMap(({ id, draftTargetId }) => [id, draftTargetId]),\n          foreignKeyColumn,\n          'id',\n          ...updates.map(({ id }) => id),\n        ]\n      );\n    }\n  }\n}\n\n/**\n * Fixes existing v4 draft entries' join table relations by converting published targets to draft targets.\n * This ensures that draft entries point to draft targets, not published ones.\n */\nasync function fixExistingDraftRelations({ trx, uid }: { trx: Knex; uid: string }) {\n  const meta = strapi.db.metadata.get(uid);\n  if (!meta) {\n    return;\n  }\n\n  // Get all draft entity IDs (including existing v4 drafts, not just newly created ones)\n  const draftEntities = await trx(meta.tableName).select('id').whereNull('published_at');\n\n  if (draftEntities.length === 0) {\n    return;\n  }\n\n  const draftIds = draftEntities.map((e) => Number(e.id));\n  const draftIdsChunks = chunkArray(draftIds, getBatchSize(trx, 1000));\n  const draftMapCache = new Map<string, Map<number, number> | null>();\n\n  for (const [attributeName, attribute] of Object.entries(meta.attributes) as Array<\n    [string, any]\n  >) {\n    if (attribute.type !== 'relation') {\n      continue;\n    }\n\n    const joinTable = attribute.joinTable;\n    if (!joinTable) {\n      continue;\n    }\n\n    // Skip component join tables - they are handled by fixExistingDraftComponentRelations\n    if (joinTable.name.includes('_cmps')) {\n      continue;\n    }\n\n    // Skip self-referential relations - they're handled by copyRelationsForContentType\n    if (attribute.target === uid) {\n      continue;\n    }\n\n    const targetUid = attribute.target;\n    if (!targetUid) {\n      continue;\n    }\n\n    const targetContentType = strapi.contentTypes[targetUid];\n    const targetHasDP = targetContentType?.options?.draftAndPublish;\n    if (!targetHasDP) {\n      continue;\n    }\n\n    const { name: sourceColumnName } = joinTable.joinColumn;\n    const { name: targetColumnName } = joinTable.inverseJoinColumn;\n\n    // Get draft map for target to convert published targets to draft targets\n    const targetDraftMap = await getDraftMapForTarget(trx, targetUid, draftMapCache);\n    if (!targetDraftMap || targetDraftMap.size === 0) {\n      continue;\n    }\n\n    // Get target publication states\n    const targetMeta = strapi.db.metadata.get(targetUid);\n    if (!targetMeta) {\n      continue;\n    }\n\n    for (const draftIdsChunk of draftIdsChunks) {\n      // Get all relations for these draft entries\n      const relations = await trx(joinTable.name)\n        .whereIn(sourceColumnName, draftIdsChunk)\n        .select('id', sourceColumnName, targetColumnName);\n\n      if (relations.length === 0) {\n        continue;\n      }\n\n      const targetIds = [...new Set(relations.map((r) => r[targetColumnName]).filter(Boolean))];\n      if (targetIds.length === 0) {\n        continue;\n      }\n\n      const targets = await trx(targetMeta.tableName)\n        .whereIn('id', targetIds)\n        .select('id', 'published_at');\n\n      const targetPublicationState = new Map(\n        targets.map((t) => [Number(t.id), t.published_at !== null ? 'published' : 'draft'])\n      );\n\n      // Find relations from draft entries to published targets and convert them\n      const relationsToUpdate: Array<{\n        relationId: number;\n        sourceId: number;\n        oldTargetId: number;\n        newTargetId: number;\n      }> = [];\n\n      for (const relation of relations) {\n        const targetId = Number(relation[targetColumnName]);\n        const targetState = targetPublicationState.get(targetId);\n\n        if (targetState === 'published') {\n          // This is a relation from a draft entry to a published target - convert to draft target\n          const draftTargetId = targetDraftMap.get(targetId);\n          if (draftTargetId != null) {\n            relationsToUpdate.push({\n              relationId: relation.id,\n              sourceId: Number(relation[sourceColumnName]),\n              oldTargetId: targetId,\n              newTargetId: draftTargetId,\n            });\n          }\n        }\n      }\n\n      if (relationsToUpdate.length > 0) {\n        debug(\n          `[fixExistingDraftRelations] ${uid}: Converting ${relationsToUpdate.length} relations from draft entries to published targets -> draft targets (attribute: ${attributeName}, target: ${targetUid})`\n        );\n\n        const updateChunks = chunkArray(relationsToUpdate, getBatchSize(trx, 1000));\n        for (const updateChunk of updateChunks) {\n          // Preload existing relations for this chunk to avoid N+1 lookups.\n          const existingRelationMap = await buildExistingRelationMap({\n            trx,\n            tableName: joinTable.name,\n            sourceColumnName,\n            targetColumnName,\n            updates: updateChunk.map((update) => ({\n              sourceId: update.sourceId,\n              newTargetId: update.newTargetId,\n            })),\n            batchSize: getBatchSize(trx, 100),\n          });\n\n          for (const update of updateChunk) {\n            try {\n              // Check if relation to draft target already exists\n              const key = `${update.sourceId}_${update.newTargetId}`;\n              const existingRelationId = existingRelationMap.get(key);\n\n              if (existingRelationId && existingRelationId !== update.relationId) {\n                // If relation to draft target already exists, delete the published target relation\n                await trx(joinTable.name).where('id', update.relationId).delete();\n                debug(\n                  `[fixExistingDraftRelations] ${uid}: Deleted relation ${update.relationId} (entry ${update.sourceId} -> published target ${update.oldTargetId}), draft relation already exists (-> ${update.newTargetId})`\n                );\n              } else {\n                // Update the relation to point to draft target\n                const updated = await trx(joinTable.name)\n                  .where('id', update.relationId)\n                  .update({ [targetColumnName]: update.newTargetId });\n                if (updated > 0) {\n                  debug(\n                    `[fixExistingDraftRelations] ${uid}: Updated relation ${update.relationId} (entry ${update.sourceId} -> published target ${update.oldTargetId} -> draft target ${update.newTargetId})`\n                  );\n                }\n              }\n            } catch (error: any) {\n              // If update fails due to duplicate key, try deleting the published target relation instead\n              if (isDuplicateEntryError(error)) {\n                await trx(joinTable.name).where('id', update.relationId).delete();\n                debug(\n                  `[fixExistingDraftRelations] ${uid}: Deleted relation ${update.relationId} due to duplicate key error (entry ${update.sourceId})`\n                );\n              } else {\n                throw error;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\n/**\n * Fixes existing v4 draft entries' component relations by converting published targets to draft targets.\n * This ensures that draft components point to draft targets, not published ones.\n */\nasync function fixExistingDraftComponentRelations({ trx, uid }: { trx: Knex; uid: string }) {\n  const meta = strapi.db.metadata.get(uid);\n  if (!meta) {\n    return;\n  }\n\n  const contentType = strapi.contentTypes[uid as keyof typeof strapi.contentTypes] as any;\n  const collectionName = contentType?.collectionName;\n  if (!collectionName) {\n    return;\n  }\n\n  const identifiers = strapi.db.metadata.identifiers;\n  const joinTableName = getComponentJoinTableName(collectionName, identifiers);\n  const entityIdColumn = getComponentJoinColumnEntityName(identifiers);\n  const componentIdColumn = getComponentJoinColumnInverseName(identifiers);\n  const componentTypeColumn = getComponentTypeColumn(identifiers);\n\n  const hasTable = await trx.schema.hasTable(joinTableName);\n  if (!hasTable) {\n    return;\n  }\n\n  // Get all draft entity IDs (including existing v4 drafts, not just newly created ones)\n  const draftEntities = await trx(meta.tableName).select('id').whereNull('published_at');\n\n  if (draftEntities.length === 0) {\n    return;\n  }\n\n  const draftIds = draftEntities.map((e) => Number(e.id));\n  const draftIdsChunks = chunkArray(draftIds, getBatchSize(trx, 1000));\n\n  for (const draftIdsChunk of draftIdsChunks) {\n    // Get components that belong to draft entities\n    const componentRelations = await trx(joinTableName)\n      .select('*')\n      .whereIn(entityIdColumn, draftIdsChunk);\n\n    if (componentRelations.length === 0) {\n      continue;\n    }\n\n    const componentTypes = [...new Set(componentRelations.map((r) => r[componentTypeColumn]))];\n    const draftMapCache = new Map<string, Map<number, number> | null>();\n\n    for (const componentType of componentTypes) {\n      const componentMeta = strapi.db.metadata.get(componentType);\n      if (!componentMeta) continue;\n\n      for (const [, attr] of Object.entries(componentMeta.attributes || {}) as Array<\n        [string, any]\n      >) {\n        if (attr.type !== 'relation' || !attr.joinTable) continue;\n\n        const targetUid = attr.target;\n        if (!targetUid) continue;\n\n        const targetContentType = strapi.contentTypes[targetUid];\n        const targetHasDP = targetContentType?.options?.draftAndPublish;\n        if (!targetHasDP) continue;\n\n        const relationJoinTable = attr.joinTable.name;\n        const sourceColumn = attr.joinTable.joinColumn.name;\n        const targetColumn = attr.joinTable.inverseJoinColumn.name;\n\n        const hasRelationTable = await trx.schema.hasTable(relationJoinTable);\n        if (!hasRelationTable) continue;\n\n        // Get component IDs that belong to draft entities\n        const componentIds = componentRelations\n          .filter((r) => r[componentTypeColumn] === componentType)\n          .map((r) => Number(r[componentIdColumn]));\n\n        if (componentIds.length === 0) continue;\n\n        // Get all relations for these components\n        const relations = await trx(relationJoinTable)\n          .whereIn(sourceColumn, componentIds)\n          .select('id', sourceColumn, targetColumn);\n\n        if (relations.length === 0) continue;\n\n        // Get target publication states\n        const targetMeta = strapi.db.metadata.get(targetUid);\n        if (!targetMeta) continue;\n\n        const targetIds = [...new Set(relations.map((r) => r[targetColumn]).filter(Boolean))];\n        if (targetIds.length === 0) continue;\n\n        const targets = await trx(targetMeta.tableName)\n          .whereIn('id', targetIds)\n          .select('id', 'published_at');\n\n        const targetPublicationState = new Map(\n          targets.map((t) => [Number(t.id), t.published_at !== null ? 'published' : 'draft'])\n        );\n\n        // Get draft map for target to convert published targets to draft targets\n        const targetDraftMap = await getDraftMapForTarget(trx, targetUid, draftMapCache);\n        if (!targetDraftMap || targetDraftMap.size === 0) continue;\n\n        // Find relations from draft components to published targets and convert them\n        const relationsToUpdate: Array<{\n          relationId: number;\n          componentId: number;\n          oldTargetId: number;\n          newTargetId: number;\n        }> = [];\n\n        for (const relation of relations) {\n          const targetId = Number(relation[targetColumn]);\n          const targetState = targetPublicationState.get(targetId);\n\n          if (targetState === 'published') {\n            // This is a relation from a draft component to a published target - convert to draft target\n            const draftTargetId = targetDraftMap.get(targetId);\n            if (draftTargetId != null) {\n              relationsToUpdate.push({\n                relationId: relation.id,\n                componentId: Number(relation[sourceColumn]),\n                oldTargetId: targetId,\n                newTargetId: draftTargetId,\n              });\n            }\n          }\n        }\n\n        if (relationsToUpdate.length > 0) {\n          debug(\n            `[fixExistingDraftComponentRelations] ${uid}: Converting ${relationsToUpdate.length} relations from draft components to published targets -> draft targets (component type: ${componentType}, target: ${targetUid})`\n          );\n\n          const updateChunks = chunkArray(relationsToUpdate, getBatchSize(trx, 1000));\n          for (const updateChunk of updateChunks) {\n            // Preload existing relations for this chunk to avoid N+1 lookups.\n            const existingRelationMap = await buildExistingRelationMap({\n              trx,\n              tableName: relationJoinTable,\n              sourceColumnName: sourceColumn,\n              targetColumnName: targetColumn,\n              updates: updateChunk.map((update) => ({\n                sourceId: update.componentId,\n                newTargetId: update.newTargetId,\n              })),\n              batchSize: getBatchSize(trx, 100),\n            });\n\n            for (const update of updateChunk) {\n              try {\n                // Check if relation to draft target already exists\n                const key = `${update.componentId}_${update.newTargetId}`;\n                const existingRelationId = existingRelationMap.get(key);\n\n                if (existingRelationId && existingRelationId !== update.relationId) {\n                  // If relation to draft target already exists, delete the published target relation\n                  await trx(relationJoinTable).where('id', update.relationId).delete();\n                  debug(\n                    `[fixExistingDraftComponentRelations] ${uid}: Deleted relation ${update.relationId} (component ${update.componentId} -> published target ${update.oldTargetId}), draft relation already exists (-> ${update.newTargetId})`\n                  );\n                } else {\n                  // Update the relation to point to draft target\n                  const updated = await trx(relationJoinTable)\n                    .where('id', update.relationId)\n                    .update({ [targetColumn]: update.newTargetId });\n                  if (updated > 0) {\n                    debug(\n                      `[fixExistingDraftComponentRelations] ${uid}: Updated relation ${update.relationId} (component ${update.componentId} -> published target ${update.oldTargetId} -> draft target ${update.newTargetId})`\n                    );\n                  }\n                }\n              } catch (error: any) {\n                // If update fails due to duplicate key, try deleting the published target relation instead\n                if (isDuplicateEntryError(error)) {\n                  await trx(relationJoinTable).where('id', update.relationId).delete();\n                  debug(\n                    `[fixExistingDraftComponentRelations] ${uid}: Deleted relation ${update.relationId} due to duplicate key error (component ${update.componentId})`\n                  );\n                } else {\n                  throw error;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\n/**\n * Copy component relations from published entries to draft entries\n */\nasync function copyComponentRelations({\n  trx,\n  uid,\n  publishedToDraftMap,\n}: {\n  trx: Knex;\n  uid: string;\n  publishedToDraftMap: Map<number, number>;\n}) {\n  const meta = strapi.db.metadata.get(uid);\n  if (!meta) {\n    return;\n  }\n\n  // Get collectionName from content type schema (Meta only has tableName which may be shortened)\n  const contentType = strapi.contentTypes[uid as keyof typeof strapi.contentTypes] as any;\n  const collectionName = contentType?.collectionName;\n  if (!collectionName) {\n    return;\n  }\n\n  const identifiers = strapi.db.metadata.identifiers;\n  const joinTableName = getComponentJoinTableName(collectionName, identifiers);\n  const entityIdColumn = getComponentJoinColumnEntityName(identifiers);\n  const componentIdColumn = getComponentJoinColumnInverseName(identifiers);\n  const componentTypeColumn = getComponentTypeColumn(identifiers);\n  const fieldColumn = identifiers.FIELD_COLUMN;\n\n  // Check if component join table exists\n  const hasTable = await trx.schema.hasTable(joinTableName);\n  if (!hasTable) {\n    return;\n  }\n\n  const publishedIds = Array.from(publishedToDraftMap.keys());\n\n  // Process in batches to avoid MySQL query size limits and SQLite expression tree limits\n  const publishedIdsChunks = chunkArray(publishedIds, getBatchSize(trx, 1000));\n\n  for (const publishedIdsChunk of publishedIdsChunks) {\n    // Get component relations for published entries\n    const componentRelations = await trx(joinTableName)\n      .select('*')\n      .whereIn(entityIdColumn, publishedIdsChunk);\n\n    if (componentRelations.length === 0) {\n      continue;\n    }\n\n    const componentCloneCache = new Map<string, Map<string, number>>();\n    const componentTargetDraftMapCache = new Map<string, Map<number, number> | null>();\n    const componentTargetReverseMapCache = new Map<string, Map<number, number> | null>();\n    const componentHierarchyCaches: ComponentHierarchyCaches = {\n      parentInstanceCache: new Map(),\n      ancestorDpCache: new Map(),\n      parentDpCache: new Map(),\n    };\n\n    // Filter component relations: only propagate if component's parent in the component hierarchy doesn't have draft/publish\n    // This matches discardDraft() behavior via shouldPropagateComponentRelationToNewVersion\n    //\n    // The logic: find what contains this component instance (could be a content type or another component).\n    // If it's a component, recursively check its parents. If any parent in the chain has DP, filter out the relation.\n    // Filter in batches to cap memory use and DB fan-out when relations are large.\n    const filteredComponentRelations: Array<Record<string, any> | null> = [];\n    const filterBatches = chunkArray(componentRelations, getBatchSize(trx, 100));\n    for (const batch of filterBatches) {\n      const batchResults = await Promise.all(\n        batch.map(async (relation) => {\n          const componentId = relation[componentIdColumn];\n          const componentType = relation[componentTypeColumn];\n          const entityId = relation[entityIdColumn];\n\n          const componentSchema = strapi.components[\n            componentType as keyof typeof strapi.components\n          ] as any;\n\n          if (!componentSchema) {\n            debug(\n              `[copyComponentRelations] ${uid}: Keeping relation - unknown component type ${componentType} (entity: ${entityId}, componentId: ${componentId})`\n            );\n            return relation;\n          }\n\n          const componentParent = await findComponentParentInstance(\n            trx,\n            identifiers,\n            componentSchema.uid,\n            componentId,\n            uid,\n            componentHierarchyCaches\n          );\n\n          if (!componentParent) {\n            debug(\n              `[copyComponentRelations] ${uid}: Keeping relation - component ${componentType} (id: ${componentId}) is directly on entity ${entityId} (no nested parent found)`\n            );\n            return relation;\n          }\n\n          debug(\n            `[copyComponentRelations] ${uid}: Component ${componentType} (id: ${componentId}, entity: ${entityId}) has parent in hierarchy: ${componentParent.uid} (parentId: ${componentParent.parentId})`\n          );\n\n          const hasDPParent = await hasDraftPublishAncestorForParent(\n            trx,\n            identifiers,\n            componentParent,\n            componentHierarchyCaches\n          );\n\n          if (hasDPParent) {\n            debug(\n              `[copyComponentRelations] Filtering: component ${componentType} (id: ${componentId}, entity: ${entityId}) has DP parent in hierarchy (${componentParent.uid})`\n            );\n            return null;\n          }\n\n          debug(\n            `[copyComponentRelations] ${uid}: Keeping relation - component ${componentType} (id: ${componentId}, entity: ${entityId}) has no DP parent in hierarchy`\n          );\n\n          return relation;\n        })\n      );\n\n      filteredComponentRelations.push(...batchResults);\n    }\n\n    // Filter out null values (filtered relations)\n    const relationsToProcess = filteredComponentRelations.filter(Boolean) as Array<\n      Record<string, any>\n    >;\n\n    const filteredCount = componentRelations.length - relationsToProcess.length;\n    if (filteredCount > 0) {\n      debug(\n        `[copyComponentRelations] ${uid}: Filtered ${filteredCount} of ${componentRelations.length} component relations (removed ${filteredCount} with DP parents)`\n      );\n    }\n\n    // Create new component relations for draft entries\n    // Remove the 'id' field to avoid duplicate key errors\n    const mappedRelations = (\n      await Promise.all(\n        relationsToProcess.map(async (relation) => {\n          const newEntityId = getMappedValue(publishedToDraftMap, relation[entityIdColumn]);\n\n          if (!newEntityId) {\n            return null;\n          }\n\n          const componentId = relation[componentIdColumn];\n          const componentType = relation[componentTypeColumn];\n          const componentKey = `${componentId}:${newEntityId}`;\n\n          let cloneMap = componentCloneCache.get(componentType);\n          if (!cloneMap) {\n            cloneMap = new Map();\n            componentCloneCache.set(componentType, cloneMap);\n          }\n\n          let newComponentId = cloneMap.get(componentKey);\n\n          if (!newComponentId) {\n            newComponentId = await cloneComponentInstance({\n              trx,\n              componentUid: componentType,\n              componentId: Number(componentId),\n              parentUid: uid,\n              parentPublishedToDraftMap: publishedToDraftMap,\n              draftMapCache: componentTargetDraftMapCache,\n              isForDraftEntity: true,\n              reverseMapCache: componentTargetReverseMapCache,\n            });\n\n            cloneMap.set(componentKey, newComponentId);\n          }\n\n          const { id, ...relationWithoutId } = relation;\n          return {\n            ...relationWithoutId,\n            [entityIdColumn]: newEntityId,\n            [componentIdColumn]: newComponentId,\n          };\n        })\n      )\n    ).filter(Boolean) as Array<Record<string, any>>;\n\n    // Deduplicate relations based on the unique constraint columns\n    // This prevents duplicates within the same batch that could cause conflicts\n    const uniqueKeyMap = new Map<string, Record<string, any>>();\n    for (const relation of mappedRelations) {\n      const uniqueKey = `${relation[entityIdColumn]}_${relation[componentIdColumn]}_${relation[fieldColumn]}_${relation[componentTypeColumn]}`;\n      if (!uniqueKeyMap.has(uniqueKey)) {\n        uniqueKeyMap.set(uniqueKey, relation);\n      }\n    }\n    const deduplicatedRelations = Array.from(uniqueKeyMap.values());\n\n    if (deduplicatedRelations.length === 0) {\n      continue;\n    }\n\n    // Check which relations already exist in the database to avoid conflicts\n    // We need to check all unique constraint columns (entity_id, cmp_id, field, component_type)\n    // Batch the check to avoid SQLite expression tree depth limits\n    // Use smaller batches for OR queries (50 for SQLite, 100 for others)\n    const batchSize = getBatchSize(trx, 50);\n    const relationChunks = chunkArray(deduplicatedRelations, batchSize);\n    const existingKeys = new Set<string>();\n\n    for (const relationChunk of relationChunks) {\n      const existingRelations = await trx(joinTableName)\n        .select([entityIdColumn, componentIdColumn, fieldColumn, componentTypeColumn])\n        .where((qb) => {\n          // Build OR conditions for each relation in this chunk\n          for (const relation of relationChunk) {\n            qb.orWhere((subQb) => {\n              subQb\n                .where(entityIdColumn, relation[entityIdColumn])\n                .where(componentIdColumn, relation[componentIdColumn])\n                .where(fieldColumn, relation[fieldColumn])\n                .where(componentTypeColumn, relation[componentTypeColumn]);\n            });\n          }\n        });\n\n      // Add existing relation keys to the set\n      for (const existing of existingRelations) {\n        const key = `${existing[entityIdColumn]}_${existing[componentIdColumn]}_${existing[fieldColumn]}_${existing[componentTypeColumn]}`;\n        existingKeys.add(key);\n      }\n    }\n\n    // Filter out relations that already exist\n    const newComponentRelations = deduplicatedRelations.filter((relation) => {\n      const key = `${relation[entityIdColumn]}_${relation[componentIdColumn]}_${relation[fieldColumn]}_${relation[componentTypeColumn]}`;\n      return !existingKeys.has(key);\n    });\n\n    if (newComponentRelations.length > 0) {\n      // Insert component relations with PostgreSQL-specific ON CONFLICT handling\n      // Component relations use a different conflict resolution than regular relations\n      const client = trx.client.config.client;\n\n      if (client === 'postgres' || client === 'pg') {\n        // PostgreSQL: Batch insert with ON CONFLICT DO NOTHING for better throughput.\n        const relationChunks = chunkArray(newComponentRelations, getBatchSize(trx, 500));\n        let insertedCount = 0;\n        for (const relationChunk of relationChunks) {\n          await trx(joinTableName)\n            .insert(relationChunk)\n            .onConflict([entityIdColumn, componentIdColumn, fieldColumn, componentTypeColumn])\n            .ignore();\n          insertedCount += relationChunk.length;\n        }\n        if (insertedCount > 0) {\n          debug(\n            `[copyComponentRelations] ${uid}: Attempted to insert ${insertedCount} component relations (duplicates ignored)`\n          );\n        }\n      } else {\n        // MySQL and SQLite: use standard insert with duplicate handling\n        await insertRelationsWithDuplicateHandling({\n          trx,\n          tableName: joinTableName,\n          relations: newComponentRelations,\n          context: {\n            reason: 'component-relation-insert',\n            sourceUid: uid,\n          },\n        });\n      }\n    }\n  }\n}\n\n/**\n * 2 pass migration to create the draft entries for all the published entries.\n * And then copy relations directly using database queries.\n */\nconst migrateUp = async (trx: Knex, db: Database) => {\n  strapi.log.info('[discard-drafts] Migration started');\n  const dpModels = [];\n  for (const meta of db.metadata.values()) {\n    const hasDP = await hasDraftAndPublish(trx, meta);\n    if (hasDP) {\n      dpModels.push(meta);\n    }\n  }\n\n  debug(`Found ${dpModels.length} draft/publish content types to process`);\n\n  /**\n   * Create plain draft entries for all the entries that were published.\n   */\n  strapi.log.info('[discard-drafts] Stage 1/5 – cloning published entries into draft rows');\n  for (const model of dpModels) {\n    debug(` • cloning scalars for ${model.uid}`);\n    await copyPublishedEntriesToDraft({ db, trx, uid: model.uid });\n  }\n  strapi.log.info('[discard-drafts] Stage 1/5 complete');\n\n  /**\n   * Copy relations from published entries to draft entries using direct database queries.\n   * This is much more efficient than calling discardDraft for each entry.\n   */\n  strapi.log.info('[discard-drafts] Stage 2/5 – copying relations and components to drafts');\n  for (const model of dpModels) {\n    debug(` • copying relations for ${model.uid}`);\n    await copyRelationsToDrafts({ db, trx, uid: model.uid });\n  }\n  flushSkippedRelationLogs();\n  strapi.log.info('[discard-drafts] Stage 2/5 complete');\n\n  /**\n   * Fix existing v4 draft entries' join table relations to ensure they point to draft targets.\n   * In v4, draft entries might have had relations pointing to published targets. These need\n   * to be converted to point to the draft versions of those targets.\n   */\n  strapi.log.info('[discard-drafts] Stage 3/5 – fixing existing draft relations');\n  for (const model of dpModels) {\n    debug(` • fixing existing draft relations for ${model.uid}`);\n    await fixExistingDraftRelations({ trx, uid: model.uid });\n  }\n  strapi.log.info('[discard-drafts] Stage 3/5 complete');\n\n  /**\n   * Fix existing v4 draft entries' component relations to ensure they point to draft targets.\n   * In v4, draft entries might have had components pointing to published targets. These need\n   * to be converted to point to the draft versions of those targets.\n   */\n  strapi.log.info('[discard-drafts] Stage 4/5 – fixing existing draft component relations');\n  for (const model of dpModels) {\n    debug(` • fixing existing draft component relations for ${model.uid}`);\n    await fixExistingDraftComponentRelations({ trx, uid: model.uid });\n  }\n  strapi.log.info('[discard-drafts] Stage 4/5 complete');\n\n  /**\n   * Update JoinColumn relations (foreign keys) to point to draft versions\n   * This matches discard() behavior: drafts relate to drafts\n   */\n  strapi.log.info('[discard-drafts] Stage 5/5 – updating foreign key references to draft targets');\n  for (const model of dpModels) {\n    debug(` • updating join columns for ${model.uid}`);\n    await updateJoinColumnRelations({ db, trx, uid: model.uid });\n  }\n  strapi.log.info('[discard-drafts] Stage 5/5 complete');\n\n  strapi.log.info('[discard-drafts] Migration completed successfully');\n};\n\n/**\n * Load a batch of versions to discard.\n *\n * Versions with only a draft version will be ignored.\n * Only versions with a published version (which always have a draft version) will be discarded.\n */\nexport async function* getBatchToDiscard({\n  db,\n  trx,\n  uid,\n  defaultBatchSize = 1000,\n}: {\n  db: Database;\n  trx: Knex;\n  uid: string;\n  defaultBatchSize?: number;\n}) {\n  const client = db.config.connection.client;\n  const isSQLite =\n    typeof client === 'string' && ['sqlite', 'sqlite3', 'better-sqlite3'].includes(client);\n\n  // The SQLite documentation states that the maximum number of terms in a\n  // compound SELECT statement is 500 by default.\n  // See: https://www.sqlite.org/limits.html\n  // To ensure a successful migration, we limit the batch size to 500 for SQLite.\n  const batchSize = isSQLite ? Math.min(defaultBatchSize, 500) : defaultBatchSize;\n  let offset = 0;\n  let hasMore = true;\n\n  while (hasMore) {\n    // Look for the published entries to discard\n    const batch: DocumentVersion[] = await db\n      .queryBuilder(uid)\n      .select(['id', 'documentId', 'locale'])\n      .where({ publishedAt: { $ne: null } })\n      .limit(batchSize)\n      .offset(offset)\n      .orderBy('id')\n      .transacting(trx)\n      .execute();\n\n    if (batch.length < batchSize) {\n      hasMore = false;\n    }\n\n    offset += batchSize;\n    yield batch;\n  }\n}\n\nexport const discardDocumentDrafts: Migration = {\n  name: 'core::5.0.0-discard-drafts',\n  async up(trx, db) {\n    await migrateUp(trx, db);\n  },\n  async down() {\n    throw new Error('not implemented');\n  },\n};\n"],"names":["DEFAULT_PRIMARY_KEY_COLUMN","resolvePrimaryKeyColumn","meta","primaryKey","pkObject","columnName","name","attributes","attributeName","attribute","Object","entries","normalizedAttribute","column","primary","hasDraftAndPublish","trx","hasTable","schema","tableName","uid","model","strapi","getModel","hasDP","contentTypes","copyPublishedEntriesToDraft","db","metadata","get","scalarAttributes","values","reduce","acc","includes","isScalarAttribute","push","into","raw","map","join","insert","subQb","select","att","from","whereNotNull","copyRelationsToDrafts","publishedToDraftMap","buildPublishedToDraftMap","size","copyRelationsForContentType","copyRelationsFromOtherContentTypes","copyRelationsToOtherContentTypes","copyComponentRelations","chunkArray","array","chunkSize","chunks","i","length","slice","buildExistingRelationMap","sourceColumnName","targetColumnName","updates","batchSize","existingMap","Map","queryChunks","chunk","rows","where","qb","update","orWhere","sourceId","newTargetId","row","key","set","id","getBatchSize","defaultSize","client","config","isSQLite","Math","min","applyJoinTableOrdering","joinTable","seenColumns","Set","enqueueColumn","direction","has","add","orderBy","Array","isArray","clause","normalizedDirection","toLowerCase","orderColumnName","orderColumn","buildRelationKey","relation","targetId","normalizeId","fieldValue","field","componentTypeValue","component_type","getExistingRelationKeys","sourceIds","existingKeys","idChunks","existingRelationsQuery","whereIn","existingRelations","insertRelationsWithDuplicateHandling","relations","context","batchInsert","error","isDuplicateEntryError","onConflict","ignore","err","code","message","insertRowWithDuplicateHandling","componentParentSchemasCache","joinTableExistsCache","componentMetaCache","SKIPPED_RELATION_SAMPLE_LIMIT","supportsReturning","skippedRelationStats","DUPLICATE_ERROR_CODES","debug","createDebug","value","num","Number","isNaN","getMappedValue","undefined","normalized","resolveInsertedId","insertResult","first","idKey","keys","find","details","JSON","stringify","wrapped","Error","cause","toComparisonKey","String","toDisplayValue","recordSkippedRelations","skippedIds","sourceUid","stats","count","samples","flushSkippedRelationLogs","sampleArray","sampleText","targetInfo","targetUid","joinTableInfo","ellipsis","log","warn","clear","listComponentParentSchemas","componentUid","schemas","components","parents","filter","some","attr","type","component","collectionName","ensureTableExists","exists","filterRelationsWithExistingTargets","getTargetId","targetMeta","primaryKeyColumn","uniqueIdMap","uniqueIds","filteredRelations","findComponentParentInstance","identifiers","componentId","excludeUid","caches","cacheKey","parentInstanceCache","parentComponentIdColumn","getComponentJoinColumnInverseName","parentComponentTypeColumn","getComponentTypeColumn","parentEntityIdColumn","getComponentJoinColumnEntityName","potentialParents","parentSchema","parentJoinTableName","getComponentJoinTableName","parentRow","parentInstance","parentId","getComponentMeta","hasDraftPublishAncestorForParent","parent","parentDpCache","parentContentType","result","options","draftAndPublish","parentComponent","hasDraftPublishAncestorForComponent","ancestorDpCache","resolveNowValue","fn","now","Date","getDraftMapForTarget","draftMapCache","requireDraftAndPublish","getDraftToPublishedMap","reverseMapCache","draftToPublishedMap","draftMap","publishedId","draftId","getTargetPublicationState","target","published_at","mapTargetId","originalId","parentUid","parentPublishedToDraftMap","isForDraftEntity","effectiveReverseCache","reverseMap","targetMap","targetState","ensureObjectWithoutId","cloned","cloneComponentRelationJoinTables","componentMeta","originalComponentId","newComponentId","joinColumn","inverseJoinColumn","relationsLogPrinted","preparedRelations","clonedRelation","originalTargetId","relationsToInsert","safeRelations","cloneComponentInstance","componentTableName","componentPrimaryKey","componentRow","newComponentRow","document_id","createId","updated_at","created_at","insertedRow","hasDraftAndPublishEnabled","publishedEntries","draftEntries","Promise","all","whereNull","i18nService","plugin","service","contentType","isLocalized","isLocalizedContentType","draftByDocumentId","draft","locale","existing","existingId","published","publishedIds","publishedIdsChunks","publishedIdsChunk","draftSourceIds","relationsQuery","newRelations","newSourceId","relationWithoutId","Boolean","reason","publishedTargetIds","draftTargetIds","models","dbModel","sourceHasDraftAndPublish","publishedIdChunks","targetMapCache","targetPublishedToDraftMap","mappedTargetId","updateJoinColumnRelations","foreignKeyColumn","draftIds","draftIdsChunks","draftIdsChunk","draftEntriesWithFk","draftEntry","publishedTargetIdRaw","normalizedPublishedTargetId","draftTargetId","caseFragments","idsPlaceholders","flatMap","fixExistingDraftRelations","draftEntities","e","targetContentType","targetHasDP","targetDraftMap","targetIds","r","targets","targetPublicationState","t","relationsToUpdate","relationId","oldTargetId","updateChunks","updateChunk","existingRelationMap","existingRelationId","delete","updated","fixExistingDraftComponentRelations","joinTableName","entityIdColumn","componentIdColumn","componentTypeColumn","componentRelations","componentTypes","componentType","relationJoinTable","sourceColumn","targetColumn","hasRelationTable","componentIds","fieldColumn","FIELD_COLUMN","componentCloneCache","componentTargetDraftMapCache","componentTargetReverseMapCache","componentHierarchyCaches","filteredComponentRelations","filterBatches","batch","batchResults","entityId","componentSchema","componentParent","hasDPParent","relationsToProcess","filteredCount","mappedRelations","newEntityId","componentKey","cloneMap","uniqueKeyMap","uniqueKey","deduplicatedRelations","relationChunks","relationChunk","newComponentRelations","insertedCount","migrateUp","info","dpModels","getBatchToDiscard","defaultBatchSize","connection","offset","hasMore","queryBuilder","publishedAt","$ne","limit","transacting","execute","discardDocumentDrafts","up","down"],"mappings":"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"}